// Code generated by Prisma CLI (https://github.com/prisma/prisma). DO NOT EDIT.
package prisma

import (
	"context"
	"fmt"
	"reflect"
	"strconv"

	"github.com/machinebox/graphql"
	"github.com/mitchellh/mapstructure"
)

// ID docs
type ID struct{}

// Queries

// Exists

// Cat exists docs
func (exists *Exists) Cat(params *CatWhereUniqueInput) bool {
	client := Client{
		Endpoint: (map[bool]string{true: exists.Endpoint, false: "https://eu1.prisma.sh/demo/go-graphql/dev"})[exists.Endpoint != ""],
		Debug:    exists.Debug,
	}
	data, err := client.Cat(
		params,
	).Exec()
	if err != nil {
		if client.Debug {
			fmt.Println("Error Exists", err)
		}
		return false
	}
	if isZeroOfUnderlyingType(data) {
		return false
	}
	return true
}

// CatParams docs
type CatParams struct {
	Where *CatWhereUniqueInput `json:"where"`
}

// Cat docs
func (client Client) Cat(params *CatWhereUniqueInput) *CatExec {

	stack := make([]Instruction, 0)
	var args []GraphQLArg
	if params != nil {
		args = append(args, GraphQLArg{
			Name:     "where",
			Key:      "where",
			TypeName: "CatWhereUniqueInput!",
			Value:    *params,
		})
	}

	stack = append(stack, Instruction{
		Name: "cat",
		Field: GraphQLField{
			Name:       "cat",
			TypeName:   "Cat",
			TypeFields: []string{"id", "name", "color"},
		},
		Operation: "query",
		Args:      args,
	})

	return &CatExec{
		client: client,
		stack:  stack,
	}
}

// CatsParams docs
type CatsParams struct {
	Where   *CatWhereInput   `json:"where,omitempty"`
	OrderBy *CatOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32           `json:"skip,omitempty"`
	After   *string          `json:"after,omitempty"`
	Before  *string          `json:"before,omitempty"`
	First   *int32           `json:"first,omitempty"`
	Last    *int32           `json:"last,omitempty"`
}

// Cats docs
func (client Client) Cats(params *CatsParams) *CatExecArray {

	stack := make([]Instruction, 0)
	var args []GraphQLArg
	if params.Where != nil {
		args = append(args, GraphQLArg{
			Name:     "where",
			Key:      "where",
			TypeName: "CatWhereInput",
			Value:    *params.Where,
		})
	}
	if params.OrderBy != nil {
		args = append(args, GraphQLArg{
			Name:     "orderBy",
			Key:      "orderBy",
			TypeName: "CatOrderByInput",
			Value:    *params.OrderBy,
		})
	}
	if params.Skip != nil {
		args = append(args, GraphQLArg{
			Name:     "skip",
			Key:      "skip",
			TypeName: "Int",
			Value:    *params.Skip,
		})
	}
	if params.After != nil {
		args = append(args, GraphQLArg{
			Name:     "after",
			Key:      "after",
			TypeName: "String",
			Value:    *params.After,
		})
	}
	if params.Before != nil {
		args = append(args, GraphQLArg{
			Name:     "before",
			Key:      "before",
			TypeName: "String",
			Value:    *params.Before,
		})
	}
	if params.First != nil {
		args = append(args, GraphQLArg{
			Name:     "first",
			Key:      "first",
			TypeName: "Int",
			Value:    *params.First,
		})
	}
	if params.Last != nil {
		args = append(args, GraphQLArg{
			Name:     "last",
			Key:      "last",
			TypeName: "Int",
			Value:    *params.Last,
		})
	}

	stack = append(stack, Instruction{
		Name: "cats",
		Field: GraphQLField{
			Name:       "cats",
			TypeName:   "Cat",
			TypeFields: []string{"id", "name", "color"},
		},
		Operation: "query",
		Args:      args,
	})

	return &CatExecArray{
		client: client,
		stack:  stack,
	}
}

// Exists

// CatsConnection exists docs
func (exists *Exists) CatsConnection(params *CatWhereInput) bool {
	client := Client{
		Endpoint: (map[bool]string{true: exists.Endpoint, false: "https://eu1.prisma.sh/demo/go-graphql/dev"})[exists.Endpoint != ""],
		Debug:    exists.Debug,
	}
	data, err := client.CatsConnection(
		&CatsConnectionParams{
			Where: params,
		},
	).Exec()
	if err != nil {
		if client.Debug {
			fmt.Println("Error Exists", err)
		}
		return false
	}
	if isZeroOfUnderlyingType(data) {
		return false
	}
	return true
}

// CatsConnectionParams docs
type CatsConnectionParams struct {
	Where   *CatWhereInput   `json:"where,omitempty"`
	OrderBy *CatOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32           `json:"skip,omitempty"`
	After   *string          `json:"after,omitempty"`
	Before  *string          `json:"before,omitempty"`
	First   *int32           `json:"first,omitempty"`
	Last    *int32           `json:"last,omitempty"`
}

// CatsConnection docs
func (client Client) CatsConnection(params *CatsConnectionParams) *CatConnectionExec {

	stack := make([]Instruction, 0)
	var args []GraphQLArg
	if params.Where != nil {
		args = append(args, GraphQLArg{
			Name:     "where",
			Key:      "where",
			TypeName: "CatWhereInput",
			Value:    *params.Where,
		})
	}
	if params.OrderBy != nil {
		args = append(args, GraphQLArg{
			Name:     "orderBy",
			Key:      "orderBy",
			TypeName: "CatOrderByInput",
			Value:    *params.OrderBy,
		})
	}
	if params.Skip != nil {
		args = append(args, GraphQLArg{
			Name:     "skip",
			Key:      "skip",
			TypeName: "Int",
			Value:    *params.Skip,
		})
	}
	if params.After != nil {
		args = append(args, GraphQLArg{
			Name:     "after",
			Key:      "after",
			TypeName: "String",
			Value:    *params.After,
		})
	}
	if params.Before != nil {
		args = append(args, GraphQLArg{
			Name:     "before",
			Key:      "before",
			TypeName: "String",
			Value:    *params.Before,
		})
	}
	if params.First != nil {
		args = append(args, GraphQLArg{
			Name:     "first",
			Key:      "first",
			TypeName: "Int",
			Value:    *params.First,
		})
	}
	if params.Last != nil {
		args = append(args, GraphQLArg{
			Name:     "last",
			Key:      "last",
			TypeName: "Int",
			Value:    *params.Last,
		})
	}

	stack = append(stack, Instruction{
		Name: "catsConnection",
		Field: GraphQLField{
			Name:       "catsConnection",
			TypeName:   "CatConnection",
			TypeFields: []string{},
		},
		Operation: "query",
		Args:      args,
	})

	return &CatConnectionExec{
		client: client,
		stack:  stack,
	}
}

// Exists

// Master exists docs
func (exists *Exists) Master(params *MasterWhereUniqueInput) bool {
	client := Client{
		Endpoint: (map[bool]string{true: exists.Endpoint, false: "https://eu1.prisma.sh/demo/go-graphql/dev"})[exists.Endpoint != ""],
		Debug:    exists.Debug,
	}
	data, err := client.Master(
		params,
	).Exec()
	if err != nil {
		if client.Debug {
			fmt.Println("Error Exists", err)
		}
		return false
	}
	if isZeroOfUnderlyingType(data) {
		return false
	}
	return true
}

// MasterParams docs
type MasterParams struct {
	Where *MasterWhereUniqueInput `json:"where"`
}

// Master docs
func (client Client) Master(params *MasterWhereUniqueInput) *MasterExec {

	stack := make([]Instruction, 0)
	var args []GraphQLArg
	if params != nil {
		args = append(args, GraphQLArg{
			Name:     "where",
			Key:      "where",
			TypeName: "MasterWhereUniqueInput!",
			Value:    *params,
		})
	}

	stack = append(stack, Instruction{
		Name: "master",
		Field: GraphQLField{
			Name:       "master",
			TypeName:   "Master",
			TypeFields: []string{"id"},
		},
		Operation: "query",
		Args:      args,
	})

	return &MasterExec{
		client: client,
		stack:  stack,
	}
}

// MastersParams docs
type MastersParams struct {
	Where   *MasterWhereInput   `json:"where,omitempty"`
	OrderBy *MasterOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32              `json:"skip,omitempty"`
	After   *string             `json:"after,omitempty"`
	Before  *string             `json:"before,omitempty"`
	First   *int32              `json:"first,omitempty"`
	Last    *int32              `json:"last,omitempty"`
}

// Masters docs
func (client Client) Masters(params *MastersParams) *MasterExecArray {

	stack := make([]Instruction, 0)
	var args []GraphQLArg
	if params.Where != nil {
		args = append(args, GraphQLArg{
			Name:     "where",
			Key:      "where",
			TypeName: "MasterWhereInput",
			Value:    *params.Where,
		})
	}
	if params.OrderBy != nil {
		args = append(args, GraphQLArg{
			Name:     "orderBy",
			Key:      "orderBy",
			TypeName: "MasterOrderByInput",
			Value:    *params.OrderBy,
		})
	}
	if params.Skip != nil {
		args = append(args, GraphQLArg{
			Name:     "skip",
			Key:      "skip",
			TypeName: "Int",
			Value:    *params.Skip,
		})
	}
	if params.After != nil {
		args = append(args, GraphQLArg{
			Name:     "after",
			Key:      "after",
			TypeName: "String",
			Value:    *params.After,
		})
	}
	if params.Before != nil {
		args = append(args, GraphQLArg{
			Name:     "before",
			Key:      "before",
			TypeName: "String",
			Value:    *params.Before,
		})
	}
	if params.First != nil {
		args = append(args, GraphQLArg{
			Name:     "first",
			Key:      "first",
			TypeName: "Int",
			Value:    *params.First,
		})
	}
	if params.Last != nil {
		args = append(args, GraphQLArg{
			Name:     "last",
			Key:      "last",
			TypeName: "Int",
			Value:    *params.Last,
		})
	}

	stack = append(stack, Instruction{
		Name: "masters",
		Field: GraphQLField{
			Name:       "masters",
			TypeName:   "Master",
			TypeFields: []string{"id"},
		},
		Operation: "query",
		Args:      args,
	})

	return &MasterExecArray{
		client: client,
		stack:  stack,
	}
}

// Exists

// MastersConnection exists docs
func (exists *Exists) MastersConnection(params *MasterWhereInput) bool {
	client := Client{
		Endpoint: (map[bool]string{true: exists.Endpoint, false: "https://eu1.prisma.sh/demo/go-graphql/dev"})[exists.Endpoint != ""],
		Debug:    exists.Debug,
	}
	data, err := client.MastersConnection(
		&MastersConnectionParams{
			Where: params,
		},
	).Exec()
	if err != nil {
		if client.Debug {
			fmt.Println("Error Exists", err)
		}
		return false
	}
	if isZeroOfUnderlyingType(data) {
		return false
	}
	return true
}

// MastersConnectionParams docs
type MastersConnectionParams struct {
	Where   *MasterWhereInput   `json:"where,omitempty"`
	OrderBy *MasterOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32              `json:"skip,omitempty"`
	After   *string             `json:"after,omitempty"`
	Before  *string             `json:"before,omitempty"`
	First   *int32              `json:"first,omitempty"`
	Last    *int32              `json:"last,omitempty"`
}

// MastersConnection docs
func (client Client) MastersConnection(params *MastersConnectionParams) *MasterConnectionExec {

	stack := make([]Instruction, 0)
	var args []GraphQLArg
	if params.Where != nil {
		args = append(args, GraphQLArg{
			Name:     "where",
			Key:      "where",
			TypeName: "MasterWhereInput",
			Value:    *params.Where,
		})
	}
	if params.OrderBy != nil {
		args = append(args, GraphQLArg{
			Name:     "orderBy",
			Key:      "orderBy",
			TypeName: "MasterOrderByInput",
			Value:    *params.OrderBy,
		})
	}
	if params.Skip != nil {
		args = append(args, GraphQLArg{
			Name:     "skip",
			Key:      "skip",
			TypeName: "Int",
			Value:    *params.Skip,
		})
	}
	if params.After != nil {
		args = append(args, GraphQLArg{
			Name:     "after",
			Key:      "after",
			TypeName: "String",
			Value:    *params.After,
		})
	}
	if params.Before != nil {
		args = append(args, GraphQLArg{
			Name:     "before",
			Key:      "before",
			TypeName: "String",
			Value:    *params.Before,
		})
	}
	if params.First != nil {
		args = append(args, GraphQLArg{
			Name:     "first",
			Key:      "first",
			TypeName: "Int",
			Value:    *params.First,
		})
	}
	if params.Last != nil {
		args = append(args, GraphQLArg{
			Name:     "last",
			Key:      "last",
			TypeName: "Int",
			Value:    *params.Last,
		})
	}

	stack = append(stack, Instruction{
		Name: "mastersConnection",
		Field: GraphQLField{
			Name:       "mastersConnection",
			TypeName:   "MasterConnection",
			TypeFields: []string{},
		},
		Operation: "query",
		Args:      args,
	})

	return &MasterConnectionExec{
		client: client,
		stack:  stack,
	}
}

// NodeParams docs
type NodeParams struct {
	ID *string `json:"id"`
}

// Node docs
func (client Client) Node(params *ID) *NodeExec {

	stack := make([]Instruction, 0)
	var args []GraphQLArg
	if params != nil {
		args = append(args, GraphQLArg{
			Name:     "id",
			Key:      "id",
			TypeName: "ID!",
			Value:    *params,
		})
	}

	stack = append(stack, Instruction{
		Name: "node",
		Field: GraphQLField{
			Name:       "node",
			TypeName:   "Node",
			TypeFields: []string{},
		},
		Operation: "query",
		Args:      args,
	})

	return &NodeExec{
		client: client,
		stack:  stack,
	}
}

// Mutations

// CreateCatParams docs
type CreateCatParams struct {
	Data *CatCreateInput `json:"data"`
}

// CreateCat docs
func (client Client) CreateCat(params *CatCreateInput) *CatExec {

	stack := make([]Instruction, 0)
	var args []GraphQLArg
	if params != nil {
		args = append(args, GraphQLArg{
			Name:     "data",
			Key:      "data",
			TypeName: "CatCreateInput!",
			Value:    *params,
		})
	}

	stack = append(stack, Instruction{
		Name: "createCat",
		Field: GraphQLField{
			Name:       "createCat",
			TypeName:   "Cat",
			TypeFields: []string{"id", "name", "color"},
		},
		Operation: "mutation",
		Args:      args,
	})

	return &CatExec{
		client: client,
		stack:  stack,
	}
}

// UpdateCatParams docs
type UpdateCatParams struct {
	Data  *CatUpdateInput      `json:"data"`
	Where *CatWhereUniqueInput `json:"where"`
}

// UpdateCat docs
func (client Client) UpdateCat(params *UpdateCatParams) *CatExec {

	stack := make([]Instruction, 0)
	var args []GraphQLArg
	if params.Data != nil {
		args = append(args, GraphQLArg{
			Name:     "data",
			Key:      "data",
			TypeName: "CatUpdateInput!",
			Value:    *params.Data,
		})
	}
	if params.Where != nil {
		args = append(args, GraphQLArg{
			Name:     "where",
			Key:      "where",
			TypeName: "CatWhereUniqueInput!",
			Value:    *params.Where,
		})
	}

	stack = append(stack, Instruction{
		Name: "updateCat",
		Field: GraphQLField{
			Name:       "updateCat",
			TypeName:   "Cat",
			TypeFields: []string{"id", "name", "color"},
		},
		Operation: "mutation",
		Args:      args,
	})

	return &CatExec{
		client: client,
		stack:  stack,
	}
}

// UpdateManyCatsParams docs
type UpdateManyCatsParams struct {
	Data  *CatUpdateInput `json:"data"`
	Where *CatWhereInput  `json:"where,omitempty"`
}

// UpdateManyCats docs
func (client Client) UpdateManyCats(params *UpdateManyCatsParams) *BatchPayloadExec {

	stack := make([]Instruction, 0)
	var args []GraphQLArg
	if params.Data != nil {
		args = append(args, GraphQLArg{
			Name:     "data",
			Key:      "data",
			TypeName: "CatUpdateInput!",
			Value:    *params.Data,
		})
	}
	if params.Where != nil {
		args = append(args, GraphQLArg{
			Name:     "where",
			Key:      "where",
			TypeName: "CatWhereInput",
			Value:    *params.Where,
		})
	}

	stack = append(stack, Instruction{
		Name: "updateManyCats",
		Field: GraphQLField{
			Name:       "updateManyCats",
			TypeName:   "BatchPayload",
			TypeFields: []string{"count"},
		},
		Operation: "mutation",
		Args:      args,
	})

	return &BatchPayloadExec{
		client: client,
		stack:  stack,
	}
}

// UpsertCatParams docs
type UpsertCatParams struct {
	Where  *CatWhereUniqueInput `json:"where"`
	Create *CatCreateInput      `json:"create"`
	Update *CatUpdateInput      `json:"update"`
}

// UpsertCat docs
func (client Client) UpsertCat(params *UpsertCatParams) *CatExec {

	stack := make([]Instruction, 0)
	var args []GraphQLArg
	if params.Where != nil {
		args = append(args, GraphQLArg{
			Name:     "where",
			Key:      "where",
			TypeName: "CatWhereUniqueInput!",
			Value:    *params.Where,
		})
	}
	if params.Create != nil {
		args = append(args, GraphQLArg{
			Name:     "create",
			Key:      "create",
			TypeName: "CatCreateInput!",
			Value:    *params.Create,
		})
	}
	if params.Update != nil {
		args = append(args, GraphQLArg{
			Name:     "update",
			Key:      "update",
			TypeName: "CatUpdateInput!",
			Value:    *params.Update,
		})
	}

	stack = append(stack, Instruction{
		Name: "upsertCat",
		Field: GraphQLField{
			Name:       "upsertCat",
			TypeName:   "Cat",
			TypeFields: []string{"id", "name", "color"},
		},
		Operation: "mutation",
		Args:      args,
	})

	return &CatExec{
		client: client,
		stack:  stack,
	}
}

// DeleteCatParams docs
type DeleteCatParams struct {
	Where *CatWhereUniqueInput `json:"where"`
}

// DeleteCat docs
func (client Client) DeleteCat(params *CatWhereUniqueInput) *CatExec {

	stack := make([]Instruction, 0)
	var args []GraphQLArg
	if params != nil {
		args = append(args, GraphQLArg{
			Name:     "where",
			Key:      "where",
			TypeName: "CatWhereUniqueInput!",
			Value:    *params,
		})
	}

	stack = append(stack, Instruction{
		Name: "deleteCat",
		Field: GraphQLField{
			Name:       "deleteCat",
			TypeName:   "Cat",
			TypeFields: []string{"id", "name", "color"},
		},
		Operation: "mutation",
		Args:      args,
	})

	return &CatExec{
		client: client,
		stack:  stack,
	}
}

// DeleteManyCatsParams docs
type DeleteManyCatsParams struct {
	Where *CatWhereInput `json:"where,omitempty"`
}

// DeleteManyCats docs
func (client Client) DeleteManyCats(params *CatWhereInput) *BatchPayloadExec {

	stack := make([]Instruction, 0)
	var args []GraphQLArg
	if params != nil {
		args = append(args, GraphQLArg{
			Name:     "where",
			Key:      "where",
			TypeName: "CatWhereInput",
			Value:    *params,
		})
	}

	stack = append(stack, Instruction{
		Name: "deleteManyCats",
		Field: GraphQLField{
			Name:       "deleteManyCats",
			TypeName:   "BatchPayload",
			TypeFields: []string{"count"},
		},
		Operation: "mutation",
		Args:      args,
	})

	return &BatchPayloadExec{
		client: client,
		stack:  stack,
	}
}

// CreateMasterParams docs
type CreateMasterParams struct {
	Data *MasterCreateInput `json:"data"`
}

// CreateMaster docs
func (client Client) CreateMaster(params *MasterCreateInput) *MasterExec {

	stack := make([]Instruction, 0)
	var args []GraphQLArg
	if params != nil {
		args = append(args, GraphQLArg{
			Name:     "data",
			Key:      "data",
			TypeName: "MasterCreateInput!",
			Value:    *params,
		})
	}

	stack = append(stack, Instruction{
		Name: "createMaster",
		Field: GraphQLField{
			Name:       "createMaster",
			TypeName:   "Master",
			TypeFields: []string{"id"},
		},
		Operation: "mutation",
		Args:      args,
	})

	return &MasterExec{
		client: client,
		stack:  stack,
	}
}

// UpdateMasterParams docs
type UpdateMasterParams struct {
	Data  *MasterUpdateInput      `json:"data"`
	Where *MasterWhereUniqueInput `json:"where"`
}

// UpdateMaster docs
func (client Client) UpdateMaster(params *UpdateMasterParams) *MasterExec {

	stack := make([]Instruction, 0)
	var args []GraphQLArg
	if params.Data != nil {
		args = append(args, GraphQLArg{
			Name:     "data",
			Key:      "data",
			TypeName: "MasterUpdateInput!",
			Value:    *params.Data,
		})
	}
	if params.Where != nil {
		args = append(args, GraphQLArg{
			Name:     "where",
			Key:      "where",
			TypeName: "MasterWhereUniqueInput!",
			Value:    *params.Where,
		})
	}

	stack = append(stack, Instruction{
		Name: "updateMaster",
		Field: GraphQLField{
			Name:       "updateMaster",
			TypeName:   "Master",
			TypeFields: []string{"id"},
		},
		Operation: "mutation",
		Args:      args,
	})

	return &MasterExec{
		client: client,
		stack:  stack,
	}
}

// UpdateManyMastersParams docs
type UpdateManyMastersParams struct {
	Data  *MasterUpdateInput `json:"data"`
	Where *MasterWhereInput  `json:"where,omitempty"`
}

// UpdateManyMasters docs
func (client Client) UpdateManyMasters(params *UpdateManyMastersParams) *BatchPayloadExec {

	stack := make([]Instruction, 0)
	var args []GraphQLArg
	if params.Data != nil {
		args = append(args, GraphQLArg{
			Name:     "data",
			Key:      "data",
			TypeName: "MasterUpdateInput!",
			Value:    *params.Data,
		})
	}
	if params.Where != nil {
		args = append(args, GraphQLArg{
			Name:     "where",
			Key:      "where",
			TypeName: "MasterWhereInput",
			Value:    *params.Where,
		})
	}

	stack = append(stack, Instruction{
		Name: "updateManyMasters",
		Field: GraphQLField{
			Name:       "updateManyMasters",
			TypeName:   "BatchPayload",
			TypeFields: []string{"count"},
		},
		Operation: "mutation",
		Args:      args,
	})

	return &BatchPayloadExec{
		client: client,
		stack:  stack,
	}
}

// UpsertMasterParams docs
type UpsertMasterParams struct {
	Where  *MasterWhereUniqueInput `json:"where"`
	Create *MasterCreateInput      `json:"create"`
	Update *MasterUpdateInput      `json:"update"`
}

// UpsertMaster docs
func (client Client) UpsertMaster(params *UpsertMasterParams) *MasterExec {

	stack := make([]Instruction, 0)
	var args []GraphQLArg
	if params.Where != nil {
		args = append(args, GraphQLArg{
			Name:     "where",
			Key:      "where",
			TypeName: "MasterWhereUniqueInput!",
			Value:    *params.Where,
		})
	}
	if params.Create != nil {
		args = append(args, GraphQLArg{
			Name:     "create",
			Key:      "create",
			TypeName: "MasterCreateInput!",
			Value:    *params.Create,
		})
	}
	if params.Update != nil {
		args = append(args, GraphQLArg{
			Name:     "update",
			Key:      "update",
			TypeName: "MasterUpdateInput!",
			Value:    *params.Update,
		})
	}

	stack = append(stack, Instruction{
		Name: "upsertMaster",
		Field: GraphQLField{
			Name:       "upsertMaster",
			TypeName:   "Master",
			TypeFields: []string{"id"},
		},
		Operation: "mutation",
		Args:      args,
	})

	return &MasterExec{
		client: client,
		stack:  stack,
	}
}

// DeleteMasterParams docs
type DeleteMasterParams struct {
	Where *MasterWhereUniqueInput `json:"where"`
}

// DeleteMaster docs
func (client Client) DeleteMaster(params *MasterWhereUniqueInput) *MasterExec {

	stack := make([]Instruction, 0)
	var args []GraphQLArg
	if params != nil {
		args = append(args, GraphQLArg{
			Name:     "where",
			Key:      "where",
			TypeName: "MasterWhereUniqueInput!",
			Value:    *params,
		})
	}

	stack = append(stack, Instruction{
		Name: "deleteMaster",
		Field: GraphQLField{
			Name:       "deleteMaster",
			TypeName:   "Master",
			TypeFields: []string{"id"},
		},
		Operation: "mutation",
		Args:      args,
	})

	return &MasterExec{
		client: client,
		stack:  stack,
	}
}

// DeleteManyMastersParams docs
type DeleteManyMastersParams struct {
	Where *MasterWhereInput `json:"where,omitempty"`
}

// DeleteManyMasters docs
func (client Client) DeleteManyMasters(params *MasterWhereInput) *BatchPayloadExec {

	stack := make([]Instruction, 0)
	var args []GraphQLArg
	if params != nil {
		args = append(args, GraphQLArg{
			Name:     "where",
			Key:      "where",
			TypeName: "MasterWhereInput",
			Value:    *params,
		})
	}

	stack = append(stack, Instruction{
		Name: "deleteManyMasters",
		Field: GraphQLField{
			Name:       "deleteManyMasters",
			TypeName:   "BatchPayload",
			TypeFields: []string{"count"},
		},
		Operation: "mutation",
		Args:      args,
	})

	return &BatchPayloadExec{
		client: client,
		stack:  stack,
	}
}

// Types

// CatOrderByInput docs
type CatOrderByInput string

const (

	// IDAscCatOrderByInput docs
	IDAscCatOrderByInput CatOrderByInput = "id_ASC"

	// IDDescCatOrderByInput docs
	IDDescCatOrderByInput CatOrderByInput = "id_DESC"

	// NameAscCatOrderByInput docs
	NameAscCatOrderByInput CatOrderByInput = "name_ASC"

	// NameDescCatOrderByInput docs
	NameDescCatOrderByInput CatOrderByInput = "name_DESC"

	// ColorAscCatOrderByInput docs
	ColorAscCatOrderByInput CatOrderByInput = "color_ASC"

	// ColorDescCatOrderByInput docs
	ColorDescCatOrderByInput CatOrderByInput = "color_DESC"

	// CreatedAtAscCatOrderByInput docs
	CreatedAtAscCatOrderByInput CatOrderByInput = "createdAt_ASC"

	// CreatedAtDescCatOrderByInput docs
	CreatedAtDescCatOrderByInput CatOrderByInput = "createdAt_DESC"

	// UpdatedAtAscCatOrderByInput docs
	UpdatedAtAscCatOrderByInput CatOrderByInput = "updatedAt_ASC"

	// UpdatedAtDescCatOrderByInput docs
	UpdatedAtDescCatOrderByInput CatOrderByInput = "updatedAt_DESC"
)

// MasterOrderByInput docs
type MasterOrderByInput string

const (

	// IDAscMasterOrderByInput docs
	IDAscMasterOrderByInput MasterOrderByInput = "id_ASC"

	// IDDescMasterOrderByInput docs
	IDDescMasterOrderByInput MasterOrderByInput = "id_DESC"

	// CreatedAtAscMasterOrderByInput docs
	CreatedAtAscMasterOrderByInput MasterOrderByInput = "createdAt_ASC"

	// CreatedAtDescMasterOrderByInput docs
	CreatedAtDescMasterOrderByInput MasterOrderByInput = "createdAt_DESC"

	// UpdatedAtAscMasterOrderByInput docs
	UpdatedAtAscMasterOrderByInput MasterOrderByInput = "updatedAt_ASC"

	// UpdatedAtDescMasterOrderByInput docs
	UpdatedAtDescMasterOrderByInput MasterOrderByInput = "updatedAt_DESC"
)

// MutationType docs
type MutationType string

const (

	// CreatedMutationType docs
	CreatedMutationType MutationType = "CREATED"

	// UpdatedMutationType docs
	UpdatedMutationType MutationType = "UPDATED"

	// DeletedMutationType docs
	DeletedMutationType MutationType = "DELETED"
)

// CatCreateInput input struct docs
type CatCreateInput struct {
	Name       *string            `json:"name,omitempty"`
	Color      *string            `json:"color,omitempty"`
	FavBrother *CatCreateOneInput `json:"favBrother,omitempty"`
}

// CatWhereUniqueInput input struct docs
type CatWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

// CatUpdateOneInput input struct docs
type CatUpdateOneInput struct {
	Create     *CatCreateInput       `json:"create,omitempty"`
	Update     *CatUpdateDataInput   `json:"update,omitempty"`
	Upsert     *CatUpsertNestedInput `json:"upsert,omitempty"`
	Delete     *bool                 `json:"delete,omitempty"`
	Disconnect *bool                 `json:"disconnect,omitempty"`
	Connect    *CatWhereUniqueInput  `json:"connect,omitempty"`
}

// CatWhereInput input struct docs
type CatWhereInput struct {
	ID                 *string        `json:"id,omitempty"`
	IDNot              *string        `json:"id_not,omitempty"`
	IDIn               *string        `json:"id_in,omitempty"`
	IDNotIn            *string        `json:"id_not_in,omitempty"`
	IDLt               *string        `json:"id_lt,omitempty"`
	IDLte              *string        `json:"id_lte,omitempty"`
	IDGt               *string        `json:"id_gt,omitempty"`
	IDGte              *string        `json:"id_gte,omitempty"`
	IDContains         *string        `json:"id_contains,omitempty"`
	IDNotContains      *string        `json:"id_not_contains,omitempty"`
	IDStartsWith       *string        `json:"id_starts_with,omitempty"`
	IDNotStartsWith    *string        `json:"id_not_starts_with,omitempty"`
	IDEndsWith         *string        `json:"id_ends_with,omitempty"`
	IDNotEndsWith      *string        `json:"id_not_ends_with,omitempty"`
	Name               *string        `json:"name,omitempty"`
	NameNot            *string        `json:"name_not,omitempty"`
	NameIn             *string        `json:"name_in,omitempty"`
	NameNotIn          *string        `json:"name_not_in,omitempty"`
	NameLt             *string        `json:"name_lt,omitempty"`
	NameLte            *string        `json:"name_lte,omitempty"`
	NameGt             *string        `json:"name_gt,omitempty"`
	NameGte            *string        `json:"name_gte,omitempty"`
	NameContains       *string        `json:"name_contains,omitempty"`
	NameNotContains    *string        `json:"name_not_contains,omitempty"`
	NameStartsWith     *string        `json:"name_starts_with,omitempty"`
	NameNotStartsWith  *string        `json:"name_not_starts_with,omitempty"`
	NameEndsWith       *string        `json:"name_ends_with,omitempty"`
	NameNotEndsWith    *string        `json:"name_not_ends_with,omitempty"`
	Color              *string        `json:"color,omitempty"`
	ColorNot           *string        `json:"color_not,omitempty"`
	ColorIn            *string        `json:"color_in,omitempty"`
	ColorNotIn         *string        `json:"color_not_in,omitempty"`
	ColorLt            *string        `json:"color_lt,omitempty"`
	ColorLte           *string        `json:"color_lte,omitempty"`
	ColorGt            *string        `json:"color_gt,omitempty"`
	ColorGte           *string        `json:"color_gte,omitempty"`
	ColorContains      *string        `json:"color_contains,omitempty"`
	ColorNotContains   *string        `json:"color_not_contains,omitempty"`
	ColorStartsWith    *string        `json:"color_starts_with,omitempty"`
	ColorNotStartsWith *string        `json:"color_not_starts_with,omitempty"`
	ColorEndsWith      *string        `json:"color_ends_with,omitempty"`
	ColorNotEndsWith   *string        `json:"color_not_ends_with,omitempty"`
	FavBrother         *CatWhereInput `json:"favBrother,omitempty"`
	And                *CatWhereInput `json:"AND,omitempty"`
	Or                 *CatWhereInput `json:"OR,omitempty"`
	Not                *CatWhereInput `json:"NOT,omitempty"`
}

// CatUpdateManyInput input struct docs
type CatUpdateManyInput struct {
	Create     *CatCreateInput                      `json:"create,omitempty"`
	Delete     *CatWhereUniqueInput                 `json:"delete,omitempty"`
	Connect    *CatWhereUniqueInput                 `json:"connect,omitempty"`
	Disconnect *CatWhereUniqueInput                 `json:"disconnect,omitempty"`
	Update     *CatUpdateWithWhereUniqueNestedInput `json:"update,omitempty"`
	Upsert     *CatUpsertWithWhereUniqueNestedInput `json:"upsert,omitempty"`
}

// CatUpdateInput input struct docs
type CatUpdateInput struct {
	Name       *string            `json:"name,omitempty"`
	Color      *string            `json:"color,omitempty"`
	FavBrother *CatUpdateOneInput `json:"favBrother,omitempty"`
}

// MasterUpdateInput input struct docs
type MasterUpdateInput struct {
	Catz *CatUpdateManyInput `json:"catz,omitempty"`
}

// CatUpdateDataInput input struct docs
type CatUpdateDataInput struct {
	Name       *string            `json:"name,omitempty"`
	Color      *string            `json:"color,omitempty"`
	FavBrother *CatUpdateOneInput `json:"favBrother,omitempty"`
}

// CatCreateManyInput input struct docs
type CatCreateManyInput struct {
	Create  *CatCreateInput      `json:"create,omitempty"`
	Connect *CatWhereUniqueInput `json:"connect,omitempty"`
}

// CatSubscriptionWhereInput input struct docs
type CatSubscriptionWhereInput struct {
	MutationIn                 *MutationType              `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                    `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery *string                    `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  *string                    `json:"updatedFields_contains_some,omitempty"`
	Node                       *CatWhereInput             `json:"node,omitempty"`
	And                        *CatSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         *CatSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        *CatSubscriptionWhereInput `json:"NOT,omitempty"`
}

// MasterWhereUniqueInput input struct docs
type MasterWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

// CatCreateOneInput input struct docs
type CatCreateOneInput struct {
	Create  *CatCreateInput      `json:"create,omitempty"`
	Connect *CatWhereUniqueInput `json:"connect,omitempty"`
}

// CatUpsertNestedInput input struct docs
type CatUpsertNestedInput struct {
	Update *CatUpdateDataInput `json:"update,omitempty"`
	Create *CatCreateInput     `json:"create,omitempty"`
}

// MasterCreateInput input struct docs
type MasterCreateInput struct {
	Catz *CatCreateManyInput `json:"catz,omitempty"`
}

// CatUpdateWithWhereUniqueNestedInput input struct docs
type CatUpdateWithWhereUniqueNestedInput struct {
	Where *CatWhereUniqueInput `json:"where,omitempty"`
	Data  *CatUpdateDataInput  `json:"data,omitempty"`
}

// CatUpsertWithWhereUniqueNestedInput input struct docs
type CatUpsertWithWhereUniqueNestedInput struct {
	Where  *CatWhereUniqueInput `json:"where,omitempty"`
	Update *CatUpdateDataInput  `json:"update,omitempty"`
	Create *CatCreateInput      `json:"create,omitempty"`
}

// MasterSubscriptionWhereInput input struct docs
type MasterSubscriptionWhereInput struct {
	MutationIn                 *MutationType                 `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                       `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery *string                       `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  *string                       `json:"updatedFields_contains_some,omitempty"`
	Node                       *MasterWhereInput             `json:"node,omitempty"`
	And                        *MasterSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         *MasterSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        *MasterSubscriptionWhereInput `json:"NOT,omitempty"`
}

// MasterWhereInput input struct docs
type MasterWhereInput struct {
	ID              *string           `json:"id,omitempty"`
	IDNot           *string           `json:"id_not,omitempty"`
	IDIn            *string           `json:"id_in,omitempty"`
	IDNotIn         *string           `json:"id_not_in,omitempty"`
	IDLt            *string           `json:"id_lt,omitempty"`
	IDLte           *string           `json:"id_lte,omitempty"`
	IDGt            *string           `json:"id_gt,omitempty"`
	IDGte           *string           `json:"id_gte,omitempty"`
	IDContains      *string           `json:"id_contains,omitempty"`
	IDNotContains   *string           `json:"id_not_contains,omitempty"`
	IDStartsWith    *string           `json:"id_starts_with,omitempty"`
	IDNotStartsWith *string           `json:"id_not_starts_with,omitempty"`
	IDEndsWith      *string           `json:"id_ends_with,omitempty"`
	IDNotEndsWith   *string           `json:"id_not_ends_with,omitempty"`
	CatzEvery       *CatWhereInput    `json:"catz_every,omitempty"`
	CatzSome        *CatWhereInput    `json:"catz_some,omitempty"`
	CatzNone        *CatWhereInput    `json:"catz_none,omitempty"`
	And             *MasterWhereInput `json:"AND,omitempty"`
	Or              *MasterWhereInput `json:"OR,omitempty"`
	Not             *MasterWhereInput `json:"NOT,omitempty"`
}

// NodeExec docs
type NodeExec struct {
	client Client
	stack  []Instruction
}

// Node docs
type Node interface {
	ID() string
}

// MasterPreviousValuesExec docs
type MasterPreviousValuesExec struct {
	client Client
	stack  []Instruction
}

// Exec docs
func (instance MasterPreviousValuesExec) Exec() (MasterPreviousValues, error) {
	var allArgs []GraphQLArg
	variables := make(map[string]interface{})
	for instructionKey := range instance.stack {
		instruction := &instance.stack[instructionKey]
		if instance.client.Debug {
			fmt.Println("Instruction Exec: ", instruction)
		}
		for argKey := range instruction.Args {
			arg := &instruction.Args[argKey]
			if instance.client.Debug {
				fmt.Println("Instruction Arg Exec: ", instruction)
			}
			isUnique := false
			for isUnique == false {
				isUnique = true
				for key, existingArg := range allArgs {
					if existingArg.Name == arg.Name {
						isUnique = false
						arg.Name = arg.Name + "_" + strconv.Itoa(key)
						if instance.client.Debug {
							fmt.Println("Resolving Collision Arg Name: ", arg.Name)
						}
						break
					}
				}
			}
			if instance.client.Debug {
				fmt.Println("Arg Name: ", arg.Name)
			}
			allArgs = append(allArgs, *arg)
			variables[arg.Name] = arg.Value
		}
	}
	query := instance.client.ProcessInstructions(instance.stack)
	if instance.client.Debug {
		fmt.Println("Query Exec:", query)
		fmt.Println("Variables Exec:", variables)
	}
	data, err := instance.client.GraphQL(query, variables)
	if instance.client.Debug {
		fmt.Println("Data Exec:", data)
		fmt.Println("Error Exec:", err)
	}

	var genericData interface{} // This can handle both map[string]interface{} and []interface[]

	// Is unpacking needed
	dataType := reflect.TypeOf(data)
	if !isArray(dataType) {
		unpackedData := data
		for _, instruction := range instance.stack {
			if instance.client.Debug {
				fmt.Println("Original Unpacked Data Step Exec:", unpackedData)
			}
			unpackedData = (unpackedData[instruction.Name]).(map[string]interface{})
			if instance.client.Debug {
				fmt.Println("Unpacked Data Step Instruction Exec:", instruction.Name)
				fmt.Println("Unpacked Data Step Exec:", unpackedData)
				fmt.Println("Unpacked Data Step Type Exec:", reflect.TypeOf(unpackedData))
			}
			genericData = unpackedData
		}
	}
	if instance.client.Debug {
		fmt.Println("Data Unpacked Exec:", genericData)
	}

	var decodedData MasterPreviousValues
	mapstructure.Decode(genericData, &decodedData)
	if instance.client.Debug {
		fmt.Println("Data Exec Decoded:", decodedData)
	}
	return decodedData, err
}

// MasterPreviousValuesExecArray docs
type MasterPreviousValuesExecArray struct {
	client Client
	stack  []Instruction
}

// Exec docs
func (instance MasterPreviousValuesExecArray) Exec() ([]MasterPreviousValues, error) {
	query := instance.client.ProcessInstructions(instance.stack)
	variables := make(map[string]interface{})
	for _, instruction := range instance.stack {
		if instance.client.Debug {
			fmt.Println("Instruction Exec: ", instruction)
		}
		for _, arg := range instruction.Args {
			if instance.client.Debug {
				fmt.Println("Instruction Arg Exec: ", instruction)
			}
			variables[arg.Name] = arg.Value
		}
	}
	if instance.client.Debug {
		fmt.Println("Query Exec:", query)
		fmt.Println("Variables Exec:", variables)
	}
	data, err := instance.client.GraphQL(query, variables)
	if instance.client.Debug {
		fmt.Println("Data Exec:", data)
		fmt.Println("Error Exec:", err)
	}

	var genericData interface{} // This can handle both map[string]interface{} and []interface[]

	// Is unpacking needed
	dataType := reflect.TypeOf(data)
	if !isArray(dataType) {
		for _, instruction := range instance.stack {
			unpackedData := data[instruction.Name]
			if isArray(unpackedData) {
				genericData = (unpackedData).([]interface{})
			} else {
				genericData = (unpackedData).(map[string]interface{})
			}
		}
	}
	if instance.client.Debug {
		fmt.Println("Data Unpacked Exec:", genericData)
	}

	var decodedData []MasterPreviousValues
	mapstructure.Decode(genericData, &decodedData)
	if instance.client.Debug {
		fmt.Println("Data Exec Decoded:", decodedData)
	}
	return decodedData, err
}

// MasterPreviousValues docs - generated with types
type MasterPreviousValues struct {
	ID string `json:"id"`
}

// MasterExec docs
type MasterExec struct {
	client Client
	stack  []Instruction
}

// Catz docs - executable for types
func (instance *MasterExec) Catz(where *CatWhereInput, orderBy *CatOrderByInput, skip *int32, after *string, before *string, first *int32, last *int32) *CatExec {
	var args []GraphQLArg
	args = append(args, GraphQLArg{
		Name:     "where",
		Key:      "where",
		TypeName: "CatWhereInput",
		Value:    where,
	})
	args = append(args, GraphQLArg{
		Name:     "orderBy",
		Key:      "orderBy",
		TypeName: "CatOrderByInput",
		Value:    orderBy,
	})
	args = append(args, GraphQLArg{
		Name:     "skip",
		Key:      "skip",
		TypeName: "Int",
		Value:    skip,
	})
	args = append(args, GraphQLArg{
		Name:     "after",
		Key:      "after",
		TypeName: "String",
		Value:    after,
	})
	args = append(args, GraphQLArg{
		Name:     "before",
		Key:      "before",
		TypeName: "String",
		Value:    before,
	})
	args = append(args, GraphQLArg{
		Name:     "first",
		Key:      "first",
		TypeName: "Int",
		Value:    first,
	})
	args = append(args, GraphQLArg{
		Name:     "last",
		Key:      "last",
		TypeName: "Int",
		Value:    last,
	})
	instance.stack = append(instance.stack, Instruction{
		Name: "catz",
		Field: GraphQLField{
			Name:       "catz",
			TypeName:   "Cat",
			TypeFields: []string{"id", "name", "color"},
		},
		Operation: "",
		Args:      args,
	})
	return &CatExec{
		client: instance.client,
		stack:  instance.stack,
	}
}

// Exec docs
func (instance MasterExec) Exec() (Master, error) {
	var allArgs []GraphQLArg
	variables := make(map[string]interface{})
	for instructionKey := range instance.stack {
		instruction := &instance.stack[instructionKey]
		if instance.client.Debug {
			fmt.Println("Instruction Exec: ", instruction)
		}
		for argKey := range instruction.Args {
			arg := &instruction.Args[argKey]
			if instance.client.Debug {
				fmt.Println("Instruction Arg Exec: ", instruction)
			}
			isUnique := false
			for isUnique == false {
				isUnique = true
				for key, existingArg := range allArgs {
					if existingArg.Name == arg.Name {
						isUnique = false
						arg.Name = arg.Name + "_" + strconv.Itoa(key)
						if instance.client.Debug {
							fmt.Println("Resolving Collision Arg Name: ", arg.Name)
						}
						break
					}
				}
			}
			if instance.client.Debug {
				fmt.Println("Arg Name: ", arg.Name)
			}
			allArgs = append(allArgs, *arg)
			variables[arg.Name] = arg.Value
		}
	}
	query := instance.client.ProcessInstructions(instance.stack)
	if instance.client.Debug {
		fmt.Println("Query Exec:", query)
		fmt.Println("Variables Exec:", variables)
	}
	data, err := instance.client.GraphQL(query, variables)
	if instance.client.Debug {
		fmt.Println("Data Exec:", data)
		fmt.Println("Error Exec:", err)
	}

	var genericData interface{} // This can handle both map[string]interface{} and []interface[]

	// Is unpacking needed
	dataType := reflect.TypeOf(data)
	if !isArray(dataType) {
		unpackedData := data
		for _, instruction := range instance.stack {
			if instance.client.Debug {
				fmt.Println("Original Unpacked Data Step Exec:", unpackedData)
			}
			unpackedData = (unpackedData[instruction.Name]).(map[string]interface{})
			if instance.client.Debug {
				fmt.Println("Unpacked Data Step Instruction Exec:", instruction.Name)
				fmt.Println("Unpacked Data Step Exec:", unpackedData)
				fmt.Println("Unpacked Data Step Type Exec:", reflect.TypeOf(unpackedData))
			}
			genericData = unpackedData
		}
	}
	if instance.client.Debug {
		fmt.Println("Data Unpacked Exec:", genericData)
	}

	var decodedData Master
	mapstructure.Decode(genericData, &decodedData)
	if instance.client.Debug {
		fmt.Println("Data Exec Decoded:", decodedData)
	}
	return decodedData, err
}

// MasterExecArray docs
type MasterExecArray struct {
	client Client
	stack  []Instruction
}

// Exec docs
func (instance MasterExecArray) Exec() ([]Master, error) {
	query := instance.client.ProcessInstructions(instance.stack)
	variables := make(map[string]interface{})
	for _, instruction := range instance.stack {
		if instance.client.Debug {
			fmt.Println("Instruction Exec: ", instruction)
		}
		for _, arg := range instruction.Args {
			if instance.client.Debug {
				fmt.Println("Instruction Arg Exec: ", instruction)
			}
			variables[arg.Name] = arg.Value
		}
	}
	if instance.client.Debug {
		fmt.Println("Query Exec:", query)
		fmt.Println("Variables Exec:", variables)
	}
	data, err := instance.client.GraphQL(query, variables)
	if instance.client.Debug {
		fmt.Println("Data Exec:", data)
		fmt.Println("Error Exec:", err)
	}

	var genericData interface{} // This can handle both map[string]interface{} and []interface[]

	// Is unpacking needed
	dataType := reflect.TypeOf(data)
	if !isArray(dataType) {
		for _, instruction := range instance.stack {
			unpackedData := data[instruction.Name]
			if isArray(unpackedData) {
				genericData = (unpackedData).([]interface{})
			} else {
				genericData = (unpackedData).(map[string]interface{})
			}
		}
	}
	if instance.client.Debug {
		fmt.Println("Data Unpacked Exec:", genericData)
	}

	var decodedData []Master
	mapstructure.Decode(genericData, &decodedData)
	if instance.client.Debug {
		fmt.Println("Data Exec Decoded:", decodedData)
	}
	return decodedData, err
}

// Master docs - generated with types
type Master struct {
	ID string `json:"id"`
	// Catz *Cat   `json:"catz"`
}

// CatConnectionExec docs
type CatConnectionExec struct {
	client Client
	stack  []Instruction
}

// PageInfo docs - executable for types
func (instance *CatConnectionExec) PageInfo() *PageInfoExec {
	var args []GraphQLArg

	instance.stack = append(instance.stack, Instruction{
		Name: "pageInfo",
		Field: GraphQLField{
			Name:       "pageInfo",
			TypeName:   "PageInfo",
			TypeFields: []string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"},
		},
		Operation: "",
		Args:      args,
	})
	return &PageInfoExec{
		client: instance.client,
		stack:  instance.stack,
	}
}

// Edges docs - executable for types
func (instance *CatConnectionExec) Edges() *CatEdgeExec {
	var args []GraphQLArg

	instance.stack = append(instance.stack, Instruction{
		Name: "edges",
		Field: GraphQLField{
			Name:       "edges",
			TypeName:   "CatEdge",
			TypeFields: []string{"cursor"},
		},
		Operation: "",
		Args:      args,
	})
	return &CatEdgeExec{
		client: instance.client,
		stack:  instance.stack,
	}
}

// Aggregate docs - executable for types
func (instance *CatConnectionExec) Aggregate() *AggregateCatExec {
	var args []GraphQLArg

	instance.stack = append(instance.stack, Instruction{
		Name: "aggregate",
		Field: GraphQLField{
			Name:       "aggregate",
			TypeName:   "AggregateCat",
			TypeFields: []string{"count"},
		},
		Operation: "",
		Args:      args,
	})
	return &AggregateCatExec{
		client: instance.client,
		stack:  instance.stack,
	}
}

// Exec docs
func (instance CatConnectionExec) Exec() (CatConnection, error) {
	var allArgs []GraphQLArg
	variables := make(map[string]interface{})
	for instructionKey := range instance.stack {
		instruction := &instance.stack[instructionKey]
		if instance.client.Debug {
			fmt.Println("Instruction Exec: ", instruction)
		}
		for argKey := range instruction.Args {
			arg := &instruction.Args[argKey]
			if instance.client.Debug {
				fmt.Println("Instruction Arg Exec: ", instruction)
			}
			isUnique := false
			for isUnique == false {
				isUnique = true
				for key, existingArg := range allArgs {
					if existingArg.Name == arg.Name {
						isUnique = false
						arg.Name = arg.Name + "_" + strconv.Itoa(key)
						if instance.client.Debug {
							fmt.Println("Resolving Collision Arg Name: ", arg.Name)
						}
						break
					}
				}
			}
			if instance.client.Debug {
				fmt.Println("Arg Name: ", arg.Name)
			}
			allArgs = append(allArgs, *arg)
			variables[arg.Name] = arg.Value
		}
	}
	query := instance.client.ProcessInstructions(instance.stack)
	if instance.client.Debug {
		fmt.Println("Query Exec:", query)
		fmt.Println("Variables Exec:", variables)
	}
	data, err := instance.client.GraphQL(query, variables)
	if instance.client.Debug {
		fmt.Println("Data Exec:", data)
		fmt.Println("Error Exec:", err)
	}

	var genericData interface{} // This can handle both map[string]interface{} and []interface[]

	// Is unpacking needed
	dataType := reflect.TypeOf(data)
	if !isArray(dataType) {
		unpackedData := data
		for _, instruction := range instance.stack {
			if instance.client.Debug {
				fmt.Println("Original Unpacked Data Step Exec:", unpackedData)
			}
			unpackedData = (unpackedData[instruction.Name]).(map[string]interface{})
			if instance.client.Debug {
				fmt.Println("Unpacked Data Step Instruction Exec:", instruction.Name)
				fmt.Println("Unpacked Data Step Exec:", unpackedData)
				fmt.Println("Unpacked Data Step Type Exec:", reflect.TypeOf(unpackedData))
			}
			genericData = unpackedData
		}
	}
	if instance.client.Debug {
		fmt.Println("Data Unpacked Exec:", genericData)
	}

	var decodedData CatConnection
	mapstructure.Decode(genericData, &decodedData)
	if instance.client.Debug {
		fmt.Println("Data Exec Decoded:", decodedData)
	}
	return decodedData, err
}

// CatConnectionExecArray docs
type CatConnectionExecArray struct {
	client Client
	stack  []Instruction
}

// Exec docs
func (instance CatConnectionExecArray) Exec() ([]CatConnection, error) {
	query := instance.client.ProcessInstructions(instance.stack)
	variables := make(map[string]interface{})
	for _, instruction := range instance.stack {
		if instance.client.Debug {
			fmt.Println("Instruction Exec: ", instruction)
		}
		for _, arg := range instruction.Args {
			if instance.client.Debug {
				fmt.Println("Instruction Arg Exec: ", instruction)
			}
			variables[arg.Name] = arg.Value
		}
	}
	if instance.client.Debug {
		fmt.Println("Query Exec:", query)
		fmt.Println("Variables Exec:", variables)
	}
	data, err := instance.client.GraphQL(query, variables)
	if instance.client.Debug {
		fmt.Println("Data Exec:", data)
		fmt.Println("Error Exec:", err)
	}

	var genericData interface{} // This can handle both map[string]interface{} and []interface[]

	// Is unpacking needed
	dataType := reflect.TypeOf(data)
	if !isArray(dataType) {
		for _, instruction := range instance.stack {
			unpackedData := data[instruction.Name]
			if isArray(unpackedData) {
				genericData = (unpackedData).([]interface{})
			} else {
				genericData = (unpackedData).(map[string]interface{})
			}
		}
	}
	if instance.client.Debug {
		fmt.Println("Data Unpacked Exec:", genericData)
	}

	var decodedData []CatConnection
	mapstructure.Decode(genericData, &decodedData)
	if instance.client.Debug {
		fmt.Println("Data Exec Decoded:", decodedData)
	}
	return decodedData, err
}

// CatConnection docs - generated with types
type CatConnection struct {
	PageInfo  *PageInfo     `json:"pageInfo"`
	Edges     *CatEdge      `json:"edges"`
	Aggregate *AggregateCat `json:"aggregate"`
}

// CatPreviousValuesExec docs
type CatPreviousValuesExec struct {
	client Client
	stack  []Instruction
}

// Exec docs
func (instance CatPreviousValuesExec) Exec() (CatPreviousValues, error) {
	var allArgs []GraphQLArg
	variables := make(map[string]interface{})
	for instructionKey := range instance.stack {
		instruction := &instance.stack[instructionKey]
		if instance.client.Debug {
			fmt.Println("Instruction Exec: ", instruction)
		}
		for argKey := range instruction.Args {
			arg := &instruction.Args[argKey]
			if instance.client.Debug {
				fmt.Println("Instruction Arg Exec: ", instruction)
			}
			isUnique := false
			for isUnique == false {
				isUnique = true
				for key, existingArg := range allArgs {
					if existingArg.Name == arg.Name {
						isUnique = false
						arg.Name = arg.Name + "_" + strconv.Itoa(key)
						if instance.client.Debug {
							fmt.Println("Resolving Collision Arg Name: ", arg.Name)
						}
						break
					}
				}
			}
			if instance.client.Debug {
				fmt.Println("Arg Name: ", arg.Name)
			}
			allArgs = append(allArgs, *arg)
			variables[arg.Name] = arg.Value
		}
	}
	query := instance.client.ProcessInstructions(instance.stack)
	if instance.client.Debug {
		fmt.Println("Query Exec:", query)
		fmt.Println("Variables Exec:", variables)
	}
	data, err := instance.client.GraphQL(query, variables)
	if instance.client.Debug {
		fmt.Println("Data Exec:", data)
		fmt.Println("Error Exec:", err)
	}

	var genericData interface{} // This can handle both map[string]interface{} and []interface[]

	// Is unpacking needed
	dataType := reflect.TypeOf(data)
	if !isArray(dataType) {
		unpackedData := data
		for _, instruction := range instance.stack {
			if instance.client.Debug {
				fmt.Println("Original Unpacked Data Step Exec:", unpackedData)
			}
			unpackedData = (unpackedData[instruction.Name]).(map[string]interface{})
			if instance.client.Debug {
				fmt.Println("Unpacked Data Step Instruction Exec:", instruction.Name)
				fmt.Println("Unpacked Data Step Exec:", unpackedData)
				fmt.Println("Unpacked Data Step Type Exec:", reflect.TypeOf(unpackedData))
			}
			genericData = unpackedData
		}
	}
	if instance.client.Debug {
		fmt.Println("Data Unpacked Exec:", genericData)
	}

	var decodedData CatPreviousValues
	mapstructure.Decode(genericData, &decodedData)
	if instance.client.Debug {
		fmt.Println("Data Exec Decoded:", decodedData)
	}
	return decodedData, err
}

// CatPreviousValuesExecArray docs
type CatPreviousValuesExecArray struct {
	client Client
	stack  []Instruction
}

// Exec docs
func (instance CatPreviousValuesExecArray) Exec() ([]CatPreviousValues, error) {
	query := instance.client.ProcessInstructions(instance.stack)
	variables := make(map[string]interface{})
	for _, instruction := range instance.stack {
		if instance.client.Debug {
			fmt.Println("Instruction Exec: ", instruction)
		}
		for _, arg := range instruction.Args {
			if instance.client.Debug {
				fmt.Println("Instruction Arg Exec: ", instruction)
			}
			variables[arg.Name] = arg.Value
		}
	}
	if instance.client.Debug {
		fmt.Println("Query Exec:", query)
		fmt.Println("Variables Exec:", variables)
	}
	data, err := instance.client.GraphQL(query, variables)
	if instance.client.Debug {
		fmt.Println("Data Exec:", data)
		fmt.Println("Error Exec:", err)
	}

	var genericData interface{} // This can handle both map[string]interface{} and []interface[]

	// Is unpacking needed
	dataType := reflect.TypeOf(data)
	if !isArray(dataType) {
		for _, instruction := range instance.stack {
			unpackedData := data[instruction.Name]
			if isArray(unpackedData) {
				genericData = (unpackedData).([]interface{})
			} else {
				genericData = (unpackedData).(map[string]interface{})
			}
		}
	}
	if instance.client.Debug {
		fmt.Println("Data Unpacked Exec:", genericData)
	}

	var decodedData []CatPreviousValues
	mapstructure.Decode(genericData, &decodedData)
	if instance.client.Debug {
		fmt.Println("Data Exec Decoded:", decodedData)
	}
	return decodedData, err
}

// CatPreviousValues docs - generated with types
type CatPreviousValues struct {
	ID    string `json:"id"`
	Name  string `json:"name"`
	Color string `json:"color"`
}

// CatSubscriptionPayloadExec docs
type CatSubscriptionPayloadExec struct {
	client Client
	stack  []Instruction
}

// Node docs - executable for types
func (instance *CatSubscriptionPayloadExec) Node() *CatExec {
	var args []GraphQLArg

	instance.stack = append(instance.stack, Instruction{
		Name: "node",
		Field: GraphQLField{
			Name:       "node",
			TypeName:   "Cat",
			TypeFields: []string{"id", "name", "color"},
		},
		Operation: "",
		Args:      args,
	})
	return &CatExec{
		client: instance.client,
		stack:  instance.stack,
	}
}

// PreviousValues docs - executable for types
func (instance *CatSubscriptionPayloadExec) PreviousValues() *CatPreviousValuesExec {
	var args []GraphQLArg

	instance.stack = append(instance.stack, Instruction{
		Name: "previousValues",
		Field: GraphQLField{
			Name:       "previousValues",
			TypeName:   "CatPreviousValues",
			TypeFields: []string{"id", "name", "color"},
		},
		Operation: "",
		Args:      args,
	})
	return &CatPreviousValuesExec{
		client: instance.client,
		stack:  instance.stack,
	}
}

// Exec docs
func (instance CatSubscriptionPayloadExec) Exec() (CatSubscriptionPayload, error) {
	var allArgs []GraphQLArg
	variables := make(map[string]interface{})
	for instructionKey := range instance.stack {
		instruction := &instance.stack[instructionKey]
		if instance.client.Debug {
			fmt.Println("Instruction Exec: ", instruction)
		}
		for argKey := range instruction.Args {
			arg := &instruction.Args[argKey]
			if instance.client.Debug {
				fmt.Println("Instruction Arg Exec: ", instruction)
			}
			isUnique := false
			for isUnique == false {
				isUnique = true
				for key, existingArg := range allArgs {
					if existingArg.Name == arg.Name {
						isUnique = false
						arg.Name = arg.Name + "_" + strconv.Itoa(key)
						if instance.client.Debug {
							fmt.Println("Resolving Collision Arg Name: ", arg.Name)
						}
						break
					}
				}
			}
			if instance.client.Debug {
				fmt.Println("Arg Name: ", arg.Name)
			}
			allArgs = append(allArgs, *arg)
			variables[arg.Name] = arg.Value
		}
	}
	query := instance.client.ProcessInstructions(instance.stack)
	if instance.client.Debug {
		fmt.Println("Query Exec:", query)
		fmt.Println("Variables Exec:", variables)
	}
	data, err := instance.client.GraphQL(query, variables)
	if instance.client.Debug {
		fmt.Println("Data Exec:", data)
		fmt.Println("Error Exec:", err)
	}

	var genericData interface{} // This can handle both map[string]interface{} and []interface[]

	// Is unpacking needed
	dataType := reflect.TypeOf(data)
	if !isArray(dataType) {
		unpackedData := data
		for _, instruction := range instance.stack {
			if instance.client.Debug {
				fmt.Println("Original Unpacked Data Step Exec:", unpackedData)
			}
			unpackedData = (unpackedData[instruction.Name]).(map[string]interface{})
			if instance.client.Debug {
				fmt.Println("Unpacked Data Step Instruction Exec:", instruction.Name)
				fmt.Println("Unpacked Data Step Exec:", unpackedData)
				fmt.Println("Unpacked Data Step Type Exec:", reflect.TypeOf(unpackedData))
			}
			genericData = unpackedData
		}
	}
	if instance.client.Debug {
		fmt.Println("Data Unpacked Exec:", genericData)
	}

	var decodedData CatSubscriptionPayload
	mapstructure.Decode(genericData, &decodedData)
	if instance.client.Debug {
		fmt.Println("Data Exec Decoded:", decodedData)
	}
	return decodedData, err
}

// CatSubscriptionPayloadExecArray docs
type CatSubscriptionPayloadExecArray struct {
	client Client
	stack  []Instruction
}

// Exec docs
func (instance CatSubscriptionPayloadExecArray) Exec() ([]CatSubscriptionPayload, error) {
	query := instance.client.ProcessInstructions(instance.stack)
	variables := make(map[string]interface{})
	for _, instruction := range instance.stack {
		if instance.client.Debug {
			fmt.Println("Instruction Exec: ", instruction)
		}
		for _, arg := range instruction.Args {
			if instance.client.Debug {
				fmt.Println("Instruction Arg Exec: ", instruction)
			}
			variables[arg.Name] = arg.Value
		}
	}
	if instance.client.Debug {
		fmt.Println("Query Exec:", query)
		fmt.Println("Variables Exec:", variables)
	}
	data, err := instance.client.GraphQL(query, variables)
	if instance.client.Debug {
		fmt.Println("Data Exec:", data)
		fmt.Println("Error Exec:", err)
	}

	var genericData interface{} // This can handle both map[string]interface{} and []interface[]

	// Is unpacking needed
	dataType := reflect.TypeOf(data)
	if !isArray(dataType) {
		for _, instruction := range instance.stack {
			unpackedData := data[instruction.Name]
			if isArray(unpackedData) {
				genericData = (unpackedData).([]interface{})
			} else {
				genericData = (unpackedData).(map[string]interface{})
			}
		}
	}
	if instance.client.Debug {
		fmt.Println("Data Unpacked Exec:", genericData)
	}

	var decodedData []CatSubscriptionPayload
	mapstructure.Decode(genericData, &decodedData)
	if instance.client.Debug {
		fmt.Println("Data Exec Decoded:", decodedData)
	}
	return decodedData, err
}

// CatSubscriptionPayload docs - generated with types
type CatSubscriptionPayload struct {
	Mutation       *MutationType      `json:"mutation"`
	Node           *Cat               `json:"node,omitempty"`
	UpdatedFields  string             `json:"updatedFields"`
	PreviousValues *CatPreviousValues `json:"previousValues,omitempty"`
}

// AggregateCatExec docs
type AggregateCatExec struct {
	client Client
	stack  []Instruction
}

// Exec docs
func (instance AggregateCatExec) Exec() (AggregateCat, error) {
	var allArgs []GraphQLArg
	variables := make(map[string]interface{})
	for instructionKey := range instance.stack {
		instruction := &instance.stack[instructionKey]
		if instance.client.Debug {
			fmt.Println("Instruction Exec: ", instruction)
		}
		for argKey := range instruction.Args {
			arg := &instruction.Args[argKey]
			if instance.client.Debug {
				fmt.Println("Instruction Arg Exec: ", instruction)
			}
			isUnique := false
			for isUnique == false {
				isUnique = true
				for key, existingArg := range allArgs {
					if existingArg.Name == arg.Name {
						isUnique = false
						arg.Name = arg.Name + "_" + strconv.Itoa(key)
						if instance.client.Debug {
							fmt.Println("Resolving Collision Arg Name: ", arg.Name)
						}
						break
					}
				}
			}
			if instance.client.Debug {
				fmt.Println("Arg Name: ", arg.Name)
			}
			allArgs = append(allArgs, *arg)
			variables[arg.Name] = arg.Value
		}
	}
	query := instance.client.ProcessInstructions(instance.stack)
	if instance.client.Debug {
		fmt.Println("Query Exec:", query)
		fmt.Println("Variables Exec:", variables)
	}
	data, err := instance.client.GraphQL(query, variables)
	if instance.client.Debug {
		fmt.Println("Data Exec:", data)
		fmt.Println("Error Exec:", err)
	}

	var genericData interface{} // This can handle both map[string]interface{} and []interface[]

	// Is unpacking needed
	dataType := reflect.TypeOf(data)
	if !isArray(dataType) {
		unpackedData := data
		for _, instruction := range instance.stack {
			if instance.client.Debug {
				fmt.Println("Original Unpacked Data Step Exec:", unpackedData)
			}
			unpackedData = (unpackedData[instruction.Name]).(map[string]interface{})
			if instance.client.Debug {
				fmt.Println("Unpacked Data Step Instruction Exec:", instruction.Name)
				fmt.Println("Unpacked Data Step Exec:", unpackedData)
				fmt.Println("Unpacked Data Step Type Exec:", reflect.TypeOf(unpackedData))
			}
			genericData = unpackedData
		}
	}
	if instance.client.Debug {
		fmt.Println("Data Unpacked Exec:", genericData)
	}

	var decodedData AggregateCat
	mapstructure.Decode(genericData, &decodedData)
	if instance.client.Debug {
		fmt.Println("Data Exec Decoded:", decodedData)
	}
	return decodedData, err
}

// AggregateCatExecArray docs
type AggregateCatExecArray struct {
	client Client
	stack  []Instruction
}

// Exec docs
func (instance AggregateCatExecArray) Exec() ([]AggregateCat, error) {
	query := instance.client.ProcessInstructions(instance.stack)
	variables := make(map[string]interface{})
	for _, instruction := range instance.stack {
		if instance.client.Debug {
			fmt.Println("Instruction Exec: ", instruction)
		}
		for _, arg := range instruction.Args {
			if instance.client.Debug {
				fmt.Println("Instruction Arg Exec: ", instruction)
			}
			variables[arg.Name] = arg.Value
		}
	}
	if instance.client.Debug {
		fmt.Println("Query Exec:", query)
		fmt.Println("Variables Exec:", variables)
	}
	data, err := instance.client.GraphQL(query, variables)
	if instance.client.Debug {
		fmt.Println("Data Exec:", data)
		fmt.Println("Error Exec:", err)
	}

	var genericData interface{} // This can handle both map[string]interface{} and []interface[]

	// Is unpacking needed
	dataType := reflect.TypeOf(data)
	if !isArray(dataType) {
		for _, instruction := range instance.stack {
			unpackedData := data[instruction.Name]
			if isArray(unpackedData) {
				genericData = (unpackedData).([]interface{})
			} else {
				genericData = (unpackedData).(map[string]interface{})
			}
		}
	}
	if instance.client.Debug {
		fmt.Println("Data Unpacked Exec:", genericData)
	}

	var decodedData []AggregateCat
	mapstructure.Decode(genericData, &decodedData)
	if instance.client.Debug {
		fmt.Println("Data Exec Decoded:", decodedData)
	}
	return decodedData, err
}

// AggregateCat docs - generated with types
type AggregateCat struct {
	Count int32 `json:"count"`
}

// CatExec docs
type CatExec struct {
	client Client
	stack  []Instruction
}

// FavBrother docs - executable for types
func (instance *CatExec) FavBrother(where *CatWhereInput) *CatExec {
	var args []GraphQLArg
	args = append(args, GraphQLArg{
		Name:     "where",
		Key:      "where",
		TypeName: "CatWhereInput",
		Value:    where,
	})
	instance.stack = append(instance.stack, Instruction{
		Name: "favBrother",
		Field: GraphQLField{
			Name:       "favBrother",
			TypeName:   "Cat",
			TypeFields: []string{"id", "name", "color"},
		},
		Operation: "",
		Args:      args,
	})
	return &CatExec{
		client: instance.client,
		stack:  instance.stack,
	}
}

// Exec docs
func (instance CatExec) Exec() (Cat, error) {
	var allArgs []GraphQLArg
	variables := make(map[string]interface{})
	for instructionKey := range instance.stack {
		instruction := &instance.stack[instructionKey]
		if instance.client.Debug {
			fmt.Println("Instruction Exec: ", instruction)
		}
		for argKey := range instruction.Args {
			arg := &instruction.Args[argKey]
			if instance.client.Debug {
				fmt.Println("Instruction Arg Exec: ", instruction)
			}
			isUnique := false
			for isUnique == false {
				isUnique = true
				for key, existingArg := range allArgs {
					if existingArg.Name == arg.Name {
						isUnique = false
						arg.Name = arg.Name + "_" + strconv.Itoa(key)
						if instance.client.Debug {
							fmt.Println("Resolving Collision Arg Name: ", arg.Name)
						}
						break
					}
				}
			}
			if instance.client.Debug {
				fmt.Println("Arg Name: ", arg.Name)
			}
			allArgs = append(allArgs, *arg)
			variables[arg.Name] = arg.Value
		}
	}
	query := instance.client.ProcessInstructions(instance.stack)
	if instance.client.Debug {
		fmt.Println("Query Exec:", query)
		fmt.Println("Variables Exec:", variables)
	}
	data, err := instance.client.GraphQL(query, variables)
	if instance.client.Debug {
		fmt.Println("Data Exec:", data)
		fmt.Println("Error Exec:", err)
	}

	var genericData interface{} // This can handle both map[string]interface{} and []interface[]

	// Is unpacking needed
	dataType := reflect.TypeOf(data)
	if !isArray(dataType) {
		unpackedData := data
		for _, instruction := range instance.stack {
			if instance.client.Debug {
				fmt.Println("Original Unpacked Data Step Exec:", unpackedData)
			}
			unpackedData = (unpackedData[instruction.Name]).(map[string]interface{})
			if instance.client.Debug {
				fmt.Println("Unpacked Data Step Instruction Exec:", instruction.Name)
				fmt.Println("Unpacked Data Step Exec:", unpackedData)
				fmt.Println("Unpacked Data Step Type Exec:", reflect.TypeOf(unpackedData))
			}
			genericData = unpackedData
		}
	}
	if instance.client.Debug {
		fmt.Println("Data Unpacked Exec:", genericData)
	}

	var decodedData Cat
	mapstructure.Decode(genericData, &decodedData)
	if instance.client.Debug {
		fmt.Println("Data Exec Decoded:", decodedData)
	}
	return decodedData, err
}

// CatExecArray docs
type CatExecArray struct {
	client Client
	stack  []Instruction
}

// Exec docs
func (instance CatExecArray) Exec() ([]Cat, error) {
	query := instance.client.ProcessInstructions(instance.stack)
	variables := make(map[string]interface{})
	for _, instruction := range instance.stack {
		if instance.client.Debug {
			fmt.Println("Instruction Exec: ", instruction)
		}
		for _, arg := range instruction.Args {
			if instance.client.Debug {
				fmt.Println("Instruction Arg Exec: ", instruction)
			}
			variables[arg.Name] = arg.Value
		}
	}
	if instance.client.Debug {
		fmt.Println("Query Exec:", query)
		fmt.Println("Variables Exec:", variables)
	}
	data, err := instance.client.GraphQL(query, variables)
	if instance.client.Debug {
		fmt.Println("Data Exec:", data)
		fmt.Println("Error Exec:", err)
	}

	var genericData interface{} // This can handle both map[string]interface{} and []interface[]

	// Is unpacking needed
	dataType := reflect.TypeOf(data)
	if !isArray(dataType) {
		for _, instruction := range instance.stack {
			unpackedData := data[instruction.Name]
			if isArray(unpackedData) {
				genericData = (unpackedData).([]interface{})
			} else {
				genericData = (unpackedData).(map[string]interface{})
			}
		}
	}
	if instance.client.Debug {
		fmt.Println("Data Unpacked Exec:", genericData)
	}

	var decodedData []Cat
	mapstructure.Decode(genericData, &decodedData)
	if instance.client.Debug {
		fmt.Println("Data Exec Decoded:", decodedData)
	}
	return decodedData, err
}

// Cat docs - generated with types
type Cat struct {
	ID    string `json:"id"`
	Name  string `json:"name"`
	Color string `json:"color"`
	// FavBrother *Cat   `json:"favBrother,omitempty"`
}

// CatEdgeExec docs
type CatEdgeExec struct {
	client Client
	stack  []Instruction
}

// Node docs - executable for types
func (instance *CatEdgeExec) Node() *CatExec {
	var args []GraphQLArg

	instance.stack = append(instance.stack, Instruction{
		Name: "node",
		Field: GraphQLField{
			Name:       "node",
			TypeName:   "Cat",
			TypeFields: []string{"id", "name", "color"},
		},
		Operation: "",
		Args:      args,
	})
	return &CatExec{
		client: instance.client,
		stack:  instance.stack,
	}
}

// Exec docs
func (instance CatEdgeExec) Exec() (CatEdge, error) {
	var allArgs []GraphQLArg
	variables := make(map[string]interface{})
	for instructionKey := range instance.stack {
		instruction := &instance.stack[instructionKey]
		if instance.client.Debug {
			fmt.Println("Instruction Exec: ", instruction)
		}
		for argKey := range instruction.Args {
			arg := &instruction.Args[argKey]
			if instance.client.Debug {
				fmt.Println("Instruction Arg Exec: ", instruction)
			}
			isUnique := false
			for isUnique == false {
				isUnique = true
				for key, existingArg := range allArgs {
					if existingArg.Name == arg.Name {
						isUnique = false
						arg.Name = arg.Name + "_" + strconv.Itoa(key)
						if instance.client.Debug {
							fmt.Println("Resolving Collision Arg Name: ", arg.Name)
						}
						break
					}
				}
			}
			if instance.client.Debug {
				fmt.Println("Arg Name: ", arg.Name)
			}
			allArgs = append(allArgs, *arg)
			variables[arg.Name] = arg.Value
		}
	}
	query := instance.client.ProcessInstructions(instance.stack)
	if instance.client.Debug {
		fmt.Println("Query Exec:", query)
		fmt.Println("Variables Exec:", variables)
	}
	data, err := instance.client.GraphQL(query, variables)
	if instance.client.Debug {
		fmt.Println("Data Exec:", data)
		fmt.Println("Error Exec:", err)
	}

	var genericData interface{} // This can handle both map[string]interface{} and []interface[]

	// Is unpacking needed
	dataType := reflect.TypeOf(data)
	if !isArray(dataType) {
		unpackedData := data
		for _, instruction := range instance.stack {
			if instance.client.Debug {
				fmt.Println("Original Unpacked Data Step Exec:", unpackedData)
			}
			unpackedData = (unpackedData[instruction.Name]).(map[string]interface{})
			if instance.client.Debug {
				fmt.Println("Unpacked Data Step Instruction Exec:", instruction.Name)
				fmt.Println("Unpacked Data Step Exec:", unpackedData)
				fmt.Println("Unpacked Data Step Type Exec:", reflect.TypeOf(unpackedData))
			}
			genericData = unpackedData
		}
	}
	if instance.client.Debug {
		fmt.Println("Data Unpacked Exec:", genericData)
	}

	var decodedData CatEdge
	mapstructure.Decode(genericData, &decodedData)
	if instance.client.Debug {
		fmt.Println("Data Exec Decoded:", decodedData)
	}
	return decodedData, err
}

// CatEdgeExecArray docs
type CatEdgeExecArray struct {
	client Client
	stack  []Instruction
}

// Exec docs
func (instance CatEdgeExecArray) Exec() ([]CatEdge, error) {
	query := instance.client.ProcessInstructions(instance.stack)
	variables := make(map[string]interface{})
	for _, instruction := range instance.stack {
		if instance.client.Debug {
			fmt.Println("Instruction Exec: ", instruction)
		}
		for _, arg := range instruction.Args {
			if instance.client.Debug {
				fmt.Println("Instruction Arg Exec: ", instruction)
			}
			variables[arg.Name] = arg.Value
		}
	}
	if instance.client.Debug {
		fmt.Println("Query Exec:", query)
		fmt.Println("Variables Exec:", variables)
	}
	data, err := instance.client.GraphQL(query, variables)
	if instance.client.Debug {
		fmt.Println("Data Exec:", data)
		fmt.Println("Error Exec:", err)
	}

	var genericData interface{} // This can handle both map[string]interface{} and []interface[]

	// Is unpacking needed
	dataType := reflect.TypeOf(data)
	if !isArray(dataType) {
		for _, instruction := range instance.stack {
			unpackedData := data[instruction.Name]
			if isArray(unpackedData) {
				genericData = (unpackedData).([]interface{})
			} else {
				genericData = (unpackedData).(map[string]interface{})
			}
		}
	}
	if instance.client.Debug {
		fmt.Println("Data Unpacked Exec:", genericData)
	}

	var decodedData []CatEdge
	mapstructure.Decode(genericData, &decodedData)
	if instance.client.Debug {
		fmt.Println("Data Exec Decoded:", decodedData)
	}
	return decodedData, err
}

// CatEdge docs - generated with types
type CatEdge struct {
	Node   *Cat   `json:"node"`
	Cursor string `json:"cursor"`
}

// BatchPayloadExec docs
type BatchPayloadExec struct {
	client Client
	stack  []Instruction
}

// Exec docs
func (instance BatchPayloadExec) Exec() (BatchPayload, error) {
	var allArgs []GraphQLArg
	variables := make(map[string]interface{})
	for instructionKey := range instance.stack {
		instruction := &instance.stack[instructionKey]
		if instance.client.Debug {
			fmt.Println("Instruction Exec: ", instruction)
		}
		for argKey := range instruction.Args {
			arg := &instruction.Args[argKey]
			if instance.client.Debug {
				fmt.Println("Instruction Arg Exec: ", instruction)
			}
			isUnique := false
			for isUnique == false {
				isUnique = true
				for key, existingArg := range allArgs {
					if existingArg.Name == arg.Name {
						isUnique = false
						arg.Name = arg.Name + "_" + strconv.Itoa(key)
						if instance.client.Debug {
							fmt.Println("Resolving Collision Arg Name: ", arg.Name)
						}
						break
					}
				}
			}
			if instance.client.Debug {
				fmt.Println("Arg Name: ", arg.Name)
			}
			allArgs = append(allArgs, *arg)
			variables[arg.Name] = arg.Value
		}
	}
	query := instance.client.ProcessInstructions(instance.stack)
	if instance.client.Debug {
		fmt.Println("Query Exec:", query)
		fmt.Println("Variables Exec:", variables)
	}
	data, err := instance.client.GraphQL(query, variables)
	if instance.client.Debug {
		fmt.Println("Data Exec:", data)
		fmt.Println("Error Exec:", err)
	}

	var genericData interface{} // This can handle both map[string]interface{} and []interface[]

	// Is unpacking needed
	dataType := reflect.TypeOf(data)
	if !isArray(dataType) {
		unpackedData := data
		for _, instruction := range instance.stack {
			if instance.client.Debug {
				fmt.Println("Original Unpacked Data Step Exec:", unpackedData)
			}
			unpackedData = (unpackedData[instruction.Name]).(map[string]interface{})
			if instance.client.Debug {
				fmt.Println("Unpacked Data Step Instruction Exec:", instruction.Name)
				fmt.Println("Unpacked Data Step Exec:", unpackedData)
				fmt.Println("Unpacked Data Step Type Exec:", reflect.TypeOf(unpackedData))
			}
			genericData = unpackedData
		}
	}
	if instance.client.Debug {
		fmt.Println("Data Unpacked Exec:", genericData)
	}

	var decodedData BatchPayload
	mapstructure.Decode(genericData, &decodedData)
	if instance.client.Debug {
		fmt.Println("Data Exec Decoded:", decodedData)
	}
	return decodedData, err
}

// BatchPayloadExecArray docs
type BatchPayloadExecArray struct {
	client Client
	stack  []Instruction
}

// Exec docs
func (instance BatchPayloadExecArray) Exec() ([]BatchPayload, error) {
	query := instance.client.ProcessInstructions(instance.stack)
	variables := make(map[string]interface{})
	for _, instruction := range instance.stack {
		if instance.client.Debug {
			fmt.Println("Instruction Exec: ", instruction)
		}
		for _, arg := range instruction.Args {
			if instance.client.Debug {
				fmt.Println("Instruction Arg Exec: ", instruction)
			}
			variables[arg.Name] = arg.Value
		}
	}
	if instance.client.Debug {
		fmt.Println("Query Exec:", query)
		fmt.Println("Variables Exec:", variables)
	}
	data, err := instance.client.GraphQL(query, variables)
	if instance.client.Debug {
		fmt.Println("Data Exec:", data)
		fmt.Println("Error Exec:", err)
	}

	var genericData interface{} // This can handle both map[string]interface{} and []interface[]

	// Is unpacking needed
	dataType := reflect.TypeOf(data)
	if !isArray(dataType) {
		for _, instruction := range instance.stack {
			unpackedData := data[instruction.Name]
			if isArray(unpackedData) {
				genericData = (unpackedData).([]interface{})
			} else {
				genericData = (unpackedData).(map[string]interface{})
			}
		}
	}
	if instance.client.Debug {
		fmt.Println("Data Unpacked Exec:", genericData)
	}

	var decodedData []BatchPayload
	mapstructure.Decode(genericData, &decodedData)
	if instance.client.Debug {
		fmt.Println("Data Exec Decoded:", decodedData)
	}
	return decodedData, err
}

// BatchPayload docs - generated with types
type BatchPayload struct {
	Count int64 `json:"count"`
}

// PageInfoExec docs
type PageInfoExec struct {
	client Client
	stack  []Instruction
}

// Exec docs
func (instance PageInfoExec) Exec() (PageInfo, error) {
	var allArgs []GraphQLArg
	variables := make(map[string]interface{})
	for instructionKey := range instance.stack {
		instruction := &instance.stack[instructionKey]
		if instance.client.Debug {
			fmt.Println("Instruction Exec: ", instruction)
		}
		for argKey := range instruction.Args {
			arg := &instruction.Args[argKey]
			if instance.client.Debug {
				fmt.Println("Instruction Arg Exec: ", instruction)
			}
			isUnique := false
			for isUnique == false {
				isUnique = true
				for key, existingArg := range allArgs {
					if existingArg.Name == arg.Name {
						isUnique = false
						arg.Name = arg.Name + "_" + strconv.Itoa(key)
						if instance.client.Debug {
							fmt.Println("Resolving Collision Arg Name: ", arg.Name)
						}
						break
					}
				}
			}
			if instance.client.Debug {
				fmt.Println("Arg Name: ", arg.Name)
			}
			allArgs = append(allArgs, *arg)
			variables[arg.Name] = arg.Value
		}
	}
	query := instance.client.ProcessInstructions(instance.stack)
	if instance.client.Debug {
		fmt.Println("Query Exec:", query)
		fmt.Println("Variables Exec:", variables)
	}
	data, err := instance.client.GraphQL(query, variables)
	if instance.client.Debug {
		fmt.Println("Data Exec:", data)
		fmt.Println("Error Exec:", err)
	}

	var genericData interface{} // This can handle both map[string]interface{} and []interface[]

	// Is unpacking needed
	dataType := reflect.TypeOf(data)
	if !isArray(dataType) {
		unpackedData := data
		for _, instruction := range instance.stack {
			if instance.client.Debug {
				fmt.Println("Original Unpacked Data Step Exec:", unpackedData)
			}
			unpackedData = (unpackedData[instruction.Name]).(map[string]interface{})
			if instance.client.Debug {
				fmt.Println("Unpacked Data Step Instruction Exec:", instruction.Name)
				fmt.Println("Unpacked Data Step Exec:", unpackedData)
				fmt.Println("Unpacked Data Step Type Exec:", reflect.TypeOf(unpackedData))
			}
			genericData = unpackedData
		}
	}
	if instance.client.Debug {
		fmt.Println("Data Unpacked Exec:", genericData)
	}

	var decodedData PageInfo
	mapstructure.Decode(genericData, &decodedData)
	if instance.client.Debug {
		fmt.Println("Data Exec Decoded:", decodedData)
	}
	return decodedData, err
}

// PageInfoExecArray docs
type PageInfoExecArray struct {
	client Client
	stack  []Instruction
}

// Exec docs
func (instance PageInfoExecArray) Exec() ([]PageInfo, error) {
	query := instance.client.ProcessInstructions(instance.stack)
	variables := make(map[string]interface{})
	for _, instruction := range instance.stack {
		if instance.client.Debug {
			fmt.Println("Instruction Exec: ", instruction)
		}
		for _, arg := range instruction.Args {
			if instance.client.Debug {
				fmt.Println("Instruction Arg Exec: ", instruction)
			}
			variables[arg.Name] = arg.Value
		}
	}
	if instance.client.Debug {
		fmt.Println("Query Exec:", query)
		fmt.Println("Variables Exec:", variables)
	}
	data, err := instance.client.GraphQL(query, variables)
	if instance.client.Debug {
		fmt.Println("Data Exec:", data)
		fmt.Println("Error Exec:", err)
	}

	var genericData interface{} // This can handle both map[string]interface{} and []interface[]

	// Is unpacking needed
	dataType := reflect.TypeOf(data)
	if !isArray(dataType) {
		for _, instruction := range instance.stack {
			unpackedData := data[instruction.Name]
			if isArray(unpackedData) {
				genericData = (unpackedData).([]interface{})
			} else {
				genericData = (unpackedData).(map[string]interface{})
			}
		}
	}
	if instance.client.Debug {
		fmt.Println("Data Unpacked Exec:", genericData)
	}

	var decodedData []PageInfo
	mapstructure.Decode(genericData, &decodedData)
	if instance.client.Debug {
		fmt.Println("Data Exec Decoded:", decodedData)
	}
	return decodedData, err
}

// PageInfo docs - generated with types
type PageInfo struct {
	HasNextPage     bool   `json:"hasNextPage"`
	HasPreviousPage bool   `json:"hasPreviousPage"`
	StartCursor     string `json:"startCursor,omitempty"`
	EndCursor       string `json:"endCursor,omitempty"`
}

// MasterSubscriptionPayloadExec docs
type MasterSubscriptionPayloadExec struct {
	client Client
	stack  []Instruction
}

// Node docs - executable for types
func (instance *MasterSubscriptionPayloadExec) Node() *MasterExec {
	var args []GraphQLArg

	instance.stack = append(instance.stack, Instruction{
		Name: "node",
		Field: GraphQLField{
			Name:       "node",
			TypeName:   "Master",
			TypeFields: []string{"id"},
		},
		Operation: "",
		Args:      args,
	})
	return &MasterExec{
		client: instance.client,
		stack:  instance.stack,
	}
}

// PreviousValues docs - executable for types
func (instance *MasterSubscriptionPayloadExec) PreviousValues() *MasterPreviousValuesExec {
	var args []GraphQLArg

	instance.stack = append(instance.stack, Instruction{
		Name: "previousValues",
		Field: GraphQLField{
			Name:       "previousValues",
			TypeName:   "MasterPreviousValues",
			TypeFields: []string{"id"},
		},
		Operation: "",
		Args:      args,
	})
	return &MasterPreviousValuesExec{
		client: instance.client,
		stack:  instance.stack,
	}
}

// Exec docs
func (instance MasterSubscriptionPayloadExec) Exec() (MasterSubscriptionPayload, error) {
	var allArgs []GraphQLArg
	variables := make(map[string]interface{})
	for instructionKey := range instance.stack {
		instruction := &instance.stack[instructionKey]
		if instance.client.Debug {
			fmt.Println("Instruction Exec: ", instruction)
		}
		for argKey := range instruction.Args {
			arg := &instruction.Args[argKey]
			if instance.client.Debug {
				fmt.Println("Instruction Arg Exec: ", instruction)
			}
			isUnique := false
			for isUnique == false {
				isUnique = true
				for key, existingArg := range allArgs {
					if existingArg.Name == arg.Name {
						isUnique = false
						arg.Name = arg.Name + "_" + strconv.Itoa(key)
						if instance.client.Debug {
							fmt.Println("Resolving Collision Arg Name: ", arg.Name)
						}
						break
					}
				}
			}
			if instance.client.Debug {
				fmt.Println("Arg Name: ", arg.Name)
			}
			allArgs = append(allArgs, *arg)
			variables[arg.Name] = arg.Value
		}
	}
	query := instance.client.ProcessInstructions(instance.stack)
	if instance.client.Debug {
		fmt.Println("Query Exec:", query)
		fmt.Println("Variables Exec:", variables)
	}
	data, err := instance.client.GraphQL(query, variables)
	if instance.client.Debug {
		fmt.Println("Data Exec:", data)
		fmt.Println("Error Exec:", err)
	}

	var genericData interface{} // This can handle both map[string]interface{} and []interface[]

	// Is unpacking needed
	dataType := reflect.TypeOf(data)
	if !isArray(dataType) {
		unpackedData := data
		for _, instruction := range instance.stack {
			if instance.client.Debug {
				fmt.Println("Original Unpacked Data Step Exec:", unpackedData)
			}
			unpackedData = (unpackedData[instruction.Name]).(map[string]interface{})
			if instance.client.Debug {
				fmt.Println("Unpacked Data Step Instruction Exec:", instruction.Name)
				fmt.Println("Unpacked Data Step Exec:", unpackedData)
				fmt.Println("Unpacked Data Step Type Exec:", reflect.TypeOf(unpackedData))
			}
			genericData = unpackedData
		}
	}
	if instance.client.Debug {
		fmt.Println("Data Unpacked Exec:", genericData)
	}

	var decodedData MasterSubscriptionPayload
	mapstructure.Decode(genericData, &decodedData)
	if instance.client.Debug {
		fmt.Println("Data Exec Decoded:", decodedData)
	}
	return decodedData, err
}

// MasterSubscriptionPayloadExecArray docs
type MasterSubscriptionPayloadExecArray struct {
	client Client
	stack  []Instruction
}

// Exec docs
func (instance MasterSubscriptionPayloadExecArray) Exec() ([]MasterSubscriptionPayload, error) {
	query := instance.client.ProcessInstructions(instance.stack)
	variables := make(map[string]interface{})
	for _, instruction := range instance.stack {
		if instance.client.Debug {
			fmt.Println("Instruction Exec: ", instruction)
		}
		for _, arg := range instruction.Args {
			if instance.client.Debug {
				fmt.Println("Instruction Arg Exec: ", instruction)
			}
			variables[arg.Name] = arg.Value
		}
	}
	if instance.client.Debug {
		fmt.Println("Query Exec:", query)
		fmt.Println("Variables Exec:", variables)
	}
	data, err := instance.client.GraphQL(query, variables)
	if instance.client.Debug {
		fmt.Println("Data Exec:", data)
		fmt.Println("Error Exec:", err)
	}

	var genericData interface{} // This can handle both map[string]interface{} and []interface[]

	// Is unpacking needed
	dataType := reflect.TypeOf(data)
	if !isArray(dataType) {
		for _, instruction := range instance.stack {
			unpackedData := data[instruction.Name]
			if isArray(unpackedData) {
				genericData = (unpackedData).([]interface{})
			} else {
				genericData = (unpackedData).(map[string]interface{})
			}
		}
	}
	if instance.client.Debug {
		fmt.Println("Data Unpacked Exec:", genericData)
	}

	var decodedData []MasterSubscriptionPayload
	mapstructure.Decode(genericData, &decodedData)
	if instance.client.Debug {
		fmt.Println("Data Exec Decoded:", decodedData)
	}
	return decodedData, err
}

// MasterSubscriptionPayload docs - generated with types
type MasterSubscriptionPayload struct {
	Mutation       *MutationType         `json:"mutation"`
	Node           *Master               `json:"node,omitempty"`
	UpdatedFields  string                `json:"updatedFields"`
	PreviousValues *MasterPreviousValues `json:"previousValues,omitempty"`
}

// MasterConnectionExec docs
type MasterConnectionExec struct {
	client Client
	stack  []Instruction
}

// PageInfo docs - executable for types
func (instance *MasterConnectionExec) PageInfo() *PageInfoExec {
	var args []GraphQLArg

	instance.stack = append(instance.stack, Instruction{
		Name: "pageInfo",
		Field: GraphQLField{
			Name:       "pageInfo",
			TypeName:   "PageInfo",
			TypeFields: []string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"},
		},
		Operation: "",
		Args:      args,
	})
	return &PageInfoExec{
		client: instance.client,
		stack:  instance.stack,
	}
}

// Edges docs - executable for types
func (instance *MasterConnectionExec) Edges() *MasterEdgeExec {
	var args []GraphQLArg

	instance.stack = append(instance.stack, Instruction{
		Name: "edges",
		Field: GraphQLField{
			Name:       "edges",
			TypeName:   "MasterEdge",
			TypeFields: []string{"cursor"},
		},
		Operation: "",
		Args:      args,
	})
	return &MasterEdgeExec{
		client: instance.client,
		stack:  instance.stack,
	}
}

// Aggregate docs - executable for types
func (instance *MasterConnectionExec) Aggregate() *AggregateMasterExec {
	var args []GraphQLArg

	instance.stack = append(instance.stack, Instruction{
		Name: "aggregate",
		Field: GraphQLField{
			Name:       "aggregate",
			TypeName:   "AggregateMaster",
			TypeFields: []string{"count"},
		},
		Operation: "",
		Args:      args,
	})
	return &AggregateMasterExec{
		client: instance.client,
		stack:  instance.stack,
	}
}

// Exec docs
func (instance MasterConnectionExec) Exec() (MasterConnection, error) {
	var allArgs []GraphQLArg
	variables := make(map[string]interface{})
	for instructionKey := range instance.stack {
		instruction := &instance.stack[instructionKey]
		if instance.client.Debug {
			fmt.Println("Instruction Exec: ", instruction)
		}
		for argKey := range instruction.Args {
			arg := &instruction.Args[argKey]
			if instance.client.Debug {
				fmt.Println("Instruction Arg Exec: ", instruction)
			}
			isUnique := false
			for isUnique == false {
				isUnique = true
				for key, existingArg := range allArgs {
					if existingArg.Name == arg.Name {
						isUnique = false
						arg.Name = arg.Name + "_" + strconv.Itoa(key)
						if instance.client.Debug {
							fmt.Println("Resolving Collision Arg Name: ", arg.Name)
						}
						break
					}
				}
			}
			if instance.client.Debug {
				fmt.Println("Arg Name: ", arg.Name)
			}
			allArgs = append(allArgs, *arg)
			variables[arg.Name] = arg.Value
		}
	}
	query := instance.client.ProcessInstructions(instance.stack)
	if instance.client.Debug {
		fmt.Println("Query Exec:", query)
		fmt.Println("Variables Exec:", variables)
	}
	data, err := instance.client.GraphQL(query, variables)
	if instance.client.Debug {
		fmt.Println("Data Exec:", data)
		fmt.Println("Error Exec:", err)
	}

	var genericData interface{} // This can handle both map[string]interface{} and []interface[]

	// Is unpacking needed
	dataType := reflect.TypeOf(data)
	if !isArray(dataType) {
		unpackedData := data
		for _, instruction := range instance.stack {
			if instance.client.Debug {
				fmt.Println("Original Unpacked Data Step Exec:", unpackedData)
			}
			unpackedData = (unpackedData[instruction.Name]).(map[string]interface{})
			if instance.client.Debug {
				fmt.Println("Unpacked Data Step Instruction Exec:", instruction.Name)
				fmt.Println("Unpacked Data Step Exec:", unpackedData)
				fmt.Println("Unpacked Data Step Type Exec:", reflect.TypeOf(unpackedData))
			}
			genericData = unpackedData
		}
	}
	if instance.client.Debug {
		fmt.Println("Data Unpacked Exec:", genericData)
	}

	var decodedData MasterConnection
	mapstructure.Decode(genericData, &decodedData)
	if instance.client.Debug {
		fmt.Println("Data Exec Decoded:", decodedData)
	}
	return decodedData, err
}

// MasterConnectionExecArray docs
type MasterConnectionExecArray struct {
	client Client
	stack  []Instruction
}

// Exec docs
func (instance MasterConnectionExecArray) Exec() ([]MasterConnection, error) {
	query := instance.client.ProcessInstructions(instance.stack)
	variables := make(map[string]interface{})
	for _, instruction := range instance.stack {
		if instance.client.Debug {
			fmt.Println("Instruction Exec: ", instruction)
		}
		for _, arg := range instruction.Args {
			if instance.client.Debug {
				fmt.Println("Instruction Arg Exec: ", instruction)
			}
			variables[arg.Name] = arg.Value
		}
	}
	if instance.client.Debug {
		fmt.Println("Query Exec:", query)
		fmt.Println("Variables Exec:", variables)
	}
	data, err := instance.client.GraphQL(query, variables)
	if instance.client.Debug {
		fmt.Println("Data Exec:", data)
		fmt.Println("Error Exec:", err)
	}

	var genericData interface{} // This can handle both map[string]interface{} and []interface[]

	// Is unpacking needed
	dataType := reflect.TypeOf(data)
	if !isArray(dataType) {
		for _, instruction := range instance.stack {
			unpackedData := data[instruction.Name]
			if isArray(unpackedData) {
				genericData = (unpackedData).([]interface{})
			} else {
				genericData = (unpackedData).(map[string]interface{})
			}
		}
	}
	if instance.client.Debug {
		fmt.Println("Data Unpacked Exec:", genericData)
	}

	var decodedData []MasterConnection
	mapstructure.Decode(genericData, &decodedData)
	if instance.client.Debug {
		fmt.Println("Data Exec Decoded:", decodedData)
	}
	return decodedData, err
}

// MasterConnection docs - generated with types
type MasterConnection struct {
	PageInfo  *PageInfo        `json:"pageInfo"`
	Edges     *MasterEdge      `json:"edges"`
	Aggregate *AggregateMaster `json:"aggregate"`
}

// MasterEdgeExec docs
type MasterEdgeExec struct {
	client Client
	stack  []Instruction
}

// Node docs - executable for types
func (instance *MasterEdgeExec) Node() *MasterExec {
	var args []GraphQLArg

	instance.stack = append(instance.stack, Instruction{
		Name: "node",
		Field: GraphQLField{
			Name:       "node",
			TypeName:   "Master",
			TypeFields: []string{"id"},
		},
		Operation: "",
		Args:      args,
	})
	return &MasterExec{
		client: instance.client,
		stack:  instance.stack,
	}
}

// Exec docs
func (instance MasterEdgeExec) Exec() (MasterEdge, error) {
	var allArgs []GraphQLArg
	variables := make(map[string]interface{})
	for instructionKey := range instance.stack {
		instruction := &instance.stack[instructionKey]
		if instance.client.Debug {
			fmt.Println("Instruction Exec: ", instruction)
		}
		for argKey := range instruction.Args {
			arg := &instruction.Args[argKey]
			if instance.client.Debug {
				fmt.Println("Instruction Arg Exec: ", instruction)
			}
			isUnique := false
			for isUnique == false {
				isUnique = true
				for key, existingArg := range allArgs {
					if existingArg.Name == arg.Name {
						isUnique = false
						arg.Name = arg.Name + "_" + strconv.Itoa(key)
						if instance.client.Debug {
							fmt.Println("Resolving Collision Arg Name: ", arg.Name)
						}
						break
					}
				}
			}
			if instance.client.Debug {
				fmt.Println("Arg Name: ", arg.Name)
			}
			allArgs = append(allArgs, *arg)
			variables[arg.Name] = arg.Value
		}
	}
	query := instance.client.ProcessInstructions(instance.stack)
	if instance.client.Debug {
		fmt.Println("Query Exec:", query)
		fmt.Println("Variables Exec:", variables)
	}
	data, err := instance.client.GraphQL(query, variables)
	if instance.client.Debug {
		fmt.Println("Data Exec:", data)
		fmt.Println("Error Exec:", err)
	}

	var genericData interface{} // This can handle both map[string]interface{} and []interface[]

	// Is unpacking needed
	dataType := reflect.TypeOf(data)
	if !isArray(dataType) {
		unpackedData := data
		for _, instruction := range instance.stack {
			if instance.client.Debug {
				fmt.Println("Original Unpacked Data Step Exec:", unpackedData)
			}
			unpackedData = (unpackedData[instruction.Name]).(map[string]interface{})
			if instance.client.Debug {
				fmt.Println("Unpacked Data Step Instruction Exec:", instruction.Name)
				fmt.Println("Unpacked Data Step Exec:", unpackedData)
				fmt.Println("Unpacked Data Step Type Exec:", reflect.TypeOf(unpackedData))
			}
			genericData = unpackedData
		}
	}
	if instance.client.Debug {
		fmt.Println("Data Unpacked Exec:", genericData)
	}

	var decodedData MasterEdge
	mapstructure.Decode(genericData, &decodedData)
	if instance.client.Debug {
		fmt.Println("Data Exec Decoded:", decodedData)
	}
	return decodedData, err
}

// MasterEdgeExecArray docs
type MasterEdgeExecArray struct {
	client Client
	stack  []Instruction
}

// Exec docs
func (instance MasterEdgeExecArray) Exec() ([]MasterEdge, error) {
	query := instance.client.ProcessInstructions(instance.stack)
	variables := make(map[string]interface{})
	for _, instruction := range instance.stack {
		if instance.client.Debug {
			fmt.Println("Instruction Exec: ", instruction)
		}
		for _, arg := range instruction.Args {
			if instance.client.Debug {
				fmt.Println("Instruction Arg Exec: ", instruction)
			}
			variables[arg.Name] = arg.Value
		}
	}
	if instance.client.Debug {
		fmt.Println("Query Exec:", query)
		fmt.Println("Variables Exec:", variables)
	}
	data, err := instance.client.GraphQL(query, variables)
	if instance.client.Debug {
		fmt.Println("Data Exec:", data)
		fmt.Println("Error Exec:", err)
	}

	var genericData interface{} // This can handle both map[string]interface{} and []interface[]

	// Is unpacking needed
	dataType := reflect.TypeOf(data)
	if !isArray(dataType) {
		for _, instruction := range instance.stack {
			unpackedData := data[instruction.Name]
			if isArray(unpackedData) {
				genericData = (unpackedData).([]interface{})
			} else {
				genericData = (unpackedData).(map[string]interface{})
			}
		}
	}
	if instance.client.Debug {
		fmt.Println("Data Unpacked Exec:", genericData)
	}

	var decodedData []MasterEdge
	mapstructure.Decode(genericData, &decodedData)
	if instance.client.Debug {
		fmt.Println("Data Exec Decoded:", decodedData)
	}
	return decodedData, err
}

// MasterEdge docs - generated with types
type MasterEdge struct {
	Node   *Master `json:"node"`
	Cursor string  `json:"cursor"`
}

// AggregateMasterExec docs
type AggregateMasterExec struct {
	client Client
	stack  []Instruction
}

// Exec docs
func (instance AggregateMasterExec) Exec() (AggregateMaster, error) {
	var allArgs []GraphQLArg
	variables := make(map[string]interface{})
	for instructionKey := range instance.stack {
		instruction := &instance.stack[instructionKey]
		if instance.client.Debug {
			fmt.Println("Instruction Exec: ", instruction)
		}
		for argKey := range instruction.Args {
			arg := &instruction.Args[argKey]
			if instance.client.Debug {
				fmt.Println("Instruction Arg Exec: ", instruction)
			}
			isUnique := false
			for isUnique == false {
				isUnique = true
				for key, existingArg := range allArgs {
					if existingArg.Name == arg.Name {
						isUnique = false
						arg.Name = arg.Name + "_" + strconv.Itoa(key)
						if instance.client.Debug {
							fmt.Println("Resolving Collision Arg Name: ", arg.Name)
						}
						break
					}
				}
			}
			if instance.client.Debug {
				fmt.Println("Arg Name: ", arg.Name)
			}
			allArgs = append(allArgs, *arg)
			variables[arg.Name] = arg.Value
		}
	}
	query := instance.client.ProcessInstructions(instance.stack)
	if instance.client.Debug {
		fmt.Println("Query Exec:", query)
		fmt.Println("Variables Exec:", variables)
	}
	data, err := instance.client.GraphQL(query, variables)
	if instance.client.Debug {
		fmt.Println("Data Exec:", data)
		fmt.Println("Error Exec:", err)
	}

	var genericData interface{} // This can handle both map[string]interface{} and []interface[]

	// Is unpacking needed
	dataType := reflect.TypeOf(data)
	if !isArray(dataType) {
		unpackedData := data
		for _, instruction := range instance.stack {
			if instance.client.Debug {
				fmt.Println("Original Unpacked Data Step Exec:", unpackedData)
			}
			unpackedData = (unpackedData[instruction.Name]).(map[string]interface{})
			if instance.client.Debug {
				fmt.Println("Unpacked Data Step Instruction Exec:", instruction.Name)
				fmt.Println("Unpacked Data Step Exec:", unpackedData)
				fmt.Println("Unpacked Data Step Type Exec:", reflect.TypeOf(unpackedData))
			}
			genericData = unpackedData
		}
	}
	if instance.client.Debug {
		fmt.Println("Data Unpacked Exec:", genericData)
	}

	var decodedData AggregateMaster
	mapstructure.Decode(genericData, &decodedData)
	if instance.client.Debug {
		fmt.Println("Data Exec Decoded:", decodedData)
	}
	return decodedData, err
}

// AggregateMasterExecArray docs
type AggregateMasterExecArray struct {
	client Client
	stack  []Instruction
}

// Exec docs
func (instance AggregateMasterExecArray) Exec() ([]AggregateMaster, error) {
	query := instance.client.ProcessInstructions(instance.stack)
	variables := make(map[string]interface{})
	for _, instruction := range instance.stack {
		if instance.client.Debug {
			fmt.Println("Instruction Exec: ", instruction)
		}
		for _, arg := range instruction.Args {
			if instance.client.Debug {
				fmt.Println("Instruction Arg Exec: ", instruction)
			}
			variables[arg.Name] = arg.Value
		}
	}
	if instance.client.Debug {
		fmt.Println("Query Exec:", query)
		fmt.Println("Variables Exec:", variables)
	}
	data, err := instance.client.GraphQL(query, variables)
	if instance.client.Debug {
		fmt.Println("Data Exec:", data)
		fmt.Println("Error Exec:", err)
	}

	var genericData interface{} // This can handle both map[string]interface{} and []interface[]

	// Is unpacking needed
	dataType := reflect.TypeOf(data)
	if !isArray(dataType) {
		for _, instruction := range instance.stack {
			unpackedData := data[instruction.Name]
			if isArray(unpackedData) {
				genericData = (unpackedData).([]interface{})
			} else {
				genericData = (unpackedData).(map[string]interface{})
			}
		}
	}
	if instance.client.Debug {
		fmt.Println("Data Unpacked Exec:", genericData)
	}

	var decodedData []AggregateMaster
	mapstructure.Decode(genericData, &decodedData)
	if instance.client.Debug {
		fmt.Println("Data Exec Decoded:", decodedData)
	}
	return decodedData, err
}

// AggregateMaster docs - generated with types
type AggregateMaster struct {
	Count int32 `json:"count"`
}

// GraphQL Send a GraphQL operation request
func (client Client) GraphQL(query string, variables map[string]interface{}) (map[string]interface{}, error) {
	// TODO: Add auth support

	req := graphql.NewRequest(query)
	gqlClient := graphql.NewClient(
		(map[bool]string{true: client.Endpoint, false: "https://eu1.prisma.sh/demo/go-graphql/dev"})[client.Endpoint != ""],
	)

	for key, value := range variables {
		req.Var(key, value)
	}

	ctx := context.Background()

	// var respData ResponseStruct
	var respData map[string]interface{}
	if err := gqlClient.Run(ctx, req, &respData); err != nil {
		if client.Debug {
			fmt.Println("GraphQL Response:", respData)
		}
		return nil, err
	}
	return respData, nil
}
